''' 
    Filename:   KNN.py    
    Version:    1.0
    Since:      2013-03-19
    Author: 
        Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
        
    Edited by MacVim
    Documentation auto-generated by Snippet 
'''
import random
class KNNClassifier():
    def __init__(self, trainingData, testData,  k = 3):
        self.trainingData = trainingData
        self.testData = testData
        self.K = k

    def getFeatureVector(self, labeledObj):
        return labeledObj[0:4]

    def getLabel(self, labeledObj):
        return labeledObj[4]    

    def getEuclidianDistance(self, vec1, vec2):
#{{{
        ## Input Vector Verification
        if type(vec1) != type(vec2) or len(vec1) != len(vec2):
            print "Euclidian Distance: input vector mismatch"
            return 0;
        distance = 0
        for i in range(0,len(vec1)):
            distance += pow( vec2[i] - vec1[i],2)
        return distance
#}}}

    def getDistance(self, testObj):
        #{{{
        ''' 
        This method accept the vector of the object whose distance is to be calculated
        This method return 
            (1) Dictionary containing pairs of E-distance -> Training Data Object
            (2) List of E-distance
        '''
        distanceList = []
        distanceDict = {}
        for labeledObj in self.trainingData:
            temp = self.getEuclidianDistance( labeledObj[0:4], testObj[0:4])
            distanceList.append(temp)
            distanceDict.update({temp:labeledObj})
#}}}
        return distanceDict, distanceList
    
    def getKNearestNeighbours(self, distanceDict, distanceList):
#{{{
        neighbours = []
        distanceList = sorted(distanceList, reverse=False)

        distanceList = distanceList[0:self.K]
        for key in distanceList:
            temp = distanceDict.get(key)
            neighbours.append(temp)
#}}}
        return neighbours

    def majorityVoting(self, neighbours):
#{{{
        ## Apply Voting for neighbours 
        voting = {}
        for labeledObj in neighbours:
            key = self.getLabel(labeledObj)
            value = voting.get( key, None)
            if value is not None:
                ## increment the occurence
                voting.update({key:(value+1)})
            else:
                ## insert new piece key with occurrence 1
                voting.update({key:1})
        
        ## After voting, pick out the one was elected
        max = -1
        for label in voting:
            times = voting.get( label)
            if times > max :
                max = times
                result = label
#}}}
        return result

    def run(self):
#{{{
        result = []
        for i in range(0, len(self.testData)):
            result.append([])
        labels = []
        for testObj in self.testData:
            distanceDict, distanceList = self.getDistance( testObj)
            neighbours = self.getKNearestNeighbours( distanceDict, distanceList)
            temp = self.majorityVoting( neighbours)
            labels.append( temp)
        #print len(self.testData)
        for i in range(0, len(labels)):
            result[i] += self.testData[i] + [ labels[i] ]
            #print result[i]
#}}}
        return result

def printMatrix(matrix):
#{{{
    for row in range(0,len(matrix)):
        tempStr = ""
        for col in range(0,len(matrix[row])):
            tempStr += str(matrix[row][col]) + " "
        print tempStr
#}}}

def classMapping(flowerName):
#{{{
    if flowerName == "Iris-setosa":
        return 0
    elif flowerName == "Iris-versicolor":
        return 1
    elif flowerName == "Iris-virginica":
        return 2
    else :
        print "Flower Name Exception: unknown flower"
        return -1
#}}}

def readMatrix(filePath):
#{{{
    ## Exception handling for file opening
    try:
        IrisFile = open(filePath)
    except:
        print "Iris Data IO error, please check your input path"
    
    ## read in raw string, and store in temporary matrix (string only)
    tempList = []
    for tempStr in IrisFile: # read each line of IrisData
        tempStr = tempStr.replace("\n","")
        tempList.append( tempStr.split(",") )
    #printMatrix(tempList)

    ## now convert string to numeric value and store in another matrix IrisData
    Data = []
    for row in range(0,len(tempList)):
        temp = []
        if len(tempList[row]) < 5: ## encounter empty line
            break
        ## 0-3 features need direct conversion
        for col in range(0,4): 
            temp.append( float( tempList[row][col] ) )
        ## 4th feature need particular mapping
        temp.append( classMapping( tempList[row][4] ) )
        Data.append( temp )
    #printMatrix(IrisData)
#}}}
    return Data

def scaling(data, numOfFeatures = 4):
    ''' Scale each entry in input data to the interval [0,1]'''
#{{{
    ## Initialize the maximum and minimum of each feature
    maxList = [-9999] * numOfFeatures
    minList = [9999] * numOfFeatures

    ## Obtain the maximum and minimum by tranversal
    for row in range(0,len(data)):
        for col in range(0, numOfFeatures):
            temp = data[row][col]
            if temp > maxList[col]:
                maxList[col] = temp
                continue
            if temp < minList[col]:
                minList[col] = temp
                continue
    
    ## Start Scaling
    scaledData = []
    for row in range(0,len(data)):
        tempRow = []
        for col in range(0, numOfFeatures):
            tempEntry =  (data[row][col] - minList[col]) / (maxList[col] - minList[col])
            tempRow.append( tempEntry)
        ## directly copy the class label
        tempRow.append( data[row][numOfFeatures])
        scaledData.append( tempRow)
#}}}
    return scaledData

class CrossValidation():
    def __init__(self, rawData , foldNumber = 2):
        self.foldNumber = foldNumber
        ## copy content of rawData to self.rawData instead of copy reference
        self.rawData = []
        for row in range(0, len(rawData)):
            temp = []
            for col in range(0, len(rawData[row])):
                temp += [ rawData[row][col] ]
            self.rawData.append(temp)
        self.randomGroup = self.getRandomGroup()

    def getRandomGroup(self):
#{{{
        ## size of each group
        randomGroup = []
        for i in range(0, self.foldNumber):
            randomGroup.append([])
        Size = int(len(self.rawData) / self.foldNumber)
        for i in range(0, len(self.rawData)):
            ## form the random pool
            pool = []
            for gindex in range(0, self.foldNumber):
                temp = [gindex] * (Size - len(randomGroup[gindex]))
                pool += temp
            group = random.choice(pool)
            #print group
            randomGroup[group].append( self.rawData[i] )
#}}}
        return randomGroup

    def getError(self, result):
#{{{
        numOfMissClassified = 0
        sizeOfTestData = len(result)
        for testObj in result:
            if testObj[-2] != testObj[-1]:
                numOfMissClassified += 1
                # print testObj[-2], testObj[-1]
        errorRate = numOfMissClassified * 1.0 / sizeOfTestData
#}}}
        return errorRate

    def run(self, k = 3): # k is the neighbour parameter
#{{{
        errorList = []
        for i in range(0, self.foldNumber):
            ## separate data for training and testing
            testData = self.randomGroup[i]
            trainingData = []
            for j in range(0, self.foldNumber):
                if j != i:
                    trainingData += self.randomGroup[j]
            ## start using KNN classifier
            IrisKNN = KNNClassifier( trainingData, testData, k)
            result = IrisKNN.run()

            errorList.append( self.getError(result) )
        
        displayStr = ""
        displayStr += str(k)+"NN & " + str(self.foldNumber) + "-fold CV: "
        displayStr += "AVG: "
        displayStr += '%.2f%% ' %(100*sum(errorList)/len(errorList))
        displayStr += "Specifically,"
        for i in range(0, len(errorList)):
            displayStr += ' %.2f%%' %(100*errorList[i])
        print displayStr
#}}}
        return

def main():
    ## Data import to memory
    IrisDataFile = "./bezdekIris.data.txt"
    IrisData = readMatrix( IrisDataFile)
    ## We have to do scaling because KNN is vulnerable to bad scaling
    if False:
        scaledIrisData = scaling( IrisData)
    else:
        scaledIrisData = IrisData


    ### 4.1.1 KNN algorithm implementation (separate testData & training data Manually)
    if False:
        testData = [scaledIrisData[-1]]
        trainingData = scaledIrisData[0:-1]

        IrisKNN = KNNClassifier( trainingData, testData, k = 3)
        result = IrisKNN.run()
        for each in result:
            print each[0:-1], " prediction: ", each[-1]
    
    ### 4.1.2 Cross Validation
    ## 2-fold Cross-Validation implementation
    if True:
        twoFoldCV = CrossValidation(scaledIrisData, foldNumber = 2)
        for k in range(2, 40, 1):
            twoFoldCV.run(k)
        print ""

    ## 5-fold Cross-Validation implementation
        fiveFoldCV = CrossValidation(scaledIrisData, foldNumber = 5)
        for k in range(2, 40, 1):
            fiveFoldCV.run(k)
        print ""

    ## 10-fold Cross-Validation implementation
        tenFoldCV = CrossValidation(scaledIrisData, foldNumber = 10)
        for k in range(2, 40, 1):
            tenFoldCV.run(k)
        print ""

    ### 4.1.3 report for different k
    if False:
        twoFoldCV = CrossValidation(scaledIrisData, foldNumber = 2)
        fiveFoldCV = CrossValidation(scaledIrisData, foldNumber = 5)
        tenFoldCV = CrossValidation(scaledIrisData, foldNumber = 10)
        for k in range(2, 40, 2):
            twoFoldCV.run(k)
            fiveFoldCV.run(k)
            tenFoldCV.run(k)
            print ""


main()
