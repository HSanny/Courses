#!/Library/Frameworks/Python.framework/Versions/2.7/bin/python
''' 
    Filename:   Fisher.py    
    Version:    1.0
    Since:      2013-04-11
    Author: 
        Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
        
    Edited by MacVim
    Documentation auto-generated by Snippet 
'''
import numpy as np
import pylab as pl
import warnings

class Fisher():
    def __init__(self, data, numOfFeatures = 4):
        self.DATA = data
        self.NFEATURE = numOfFeatures

    def getWithinClassSum(self):
#{{{
        ## set up a dictionary for computing mean of each class
        sumDict = {}
        ## tranverse each data object, combine data into dictionary
        for i in range(0, len(self.DATA)):
            classNum = self.DATA[i][-1]
            if sumDict.get(classNum) is None:
                ## add new key, value is all-zero array
                sumDict.update({classNum:[ 0,np.zeros(self.NFEATURE)]})
            
            ## update existing sum of features
            numOfData = sumDict.get(classNum)[0]
            sumVector = sumDict.get(classNum)[1]
            for j in range(0, self.NFEATURE):
                sumVector[j] += self.DATA[i][j]
            sumDict.update({classNum:[numOfData+1, sumVector]})
#}}}
        return sumDict 

    def getWithinClassMean(self):
#{{{
        meanDict = {}
        sumDict = self.getWithinClassSum()
        ## convert sumVector in dictionary to be meanVector
        for classNum in sumDict:
            numOfData = sumDict.get(classNum)[0]
            sumVector = sumDict.get(classNum)[1]
            meanVector = np.divide(sumVector, numOfData)
            meanDict.update({classNum:meanVector})
#}}}
        return meanDict

    def getWithinClassVariance(self):
#{{{
        meanDict = self.getWithinClassMean()
        ## initialize the variance within class - Sw
        withinClassVariance = np.zeros((self.NFEATURE, self.NFEATURE))
        ## tranverse the data objects again to obtain variance
        for i in range(0, len(self.DATA)):
            featureVector = self.DATA[i][0:self.NFEATURE]
            classNum = self.DATA[i][-1]
            ## convert from list to array
            featureArray = np.asarray(featureVector)
            diffVector = np.subtract(featureArray, meanDict.get(classNum))
            ## convert to be transposable vector (indeed, matrix)
            diffVector = diffVector.reshape(self.NFEATURE, 1) 
            varianceMatrix = np.dot(diffVector, np.transpose(diffVector))
            ## add variance to global within-class variance
            withinClassVariance = np.add(withinClassVariance, varianceMatrix)
#}}}
        return withinClassVariance

    def getBetweenClassVariance(self):
#{{{
        sumDict = self.getWithinClassSum()
        meanDict = self.getWithinClassMean()
        globalSum = np.zeros(self.NFEATURE)
        totalObjNum = 0
        for classNum in meanDict:
            totalObjNum += sumDict.get(classNum)[0]
            globalSum = np.add(globalSum, sumDict.get(classNum)[1])
        globalMean = np.divide(globalSum, totalObjNum)
        ## initialize variance matrix
        betweenClassVariance = np.zeros((self.NFEATURE, self.NFEATURE))
        ## tranverse each class to compute variance
        for classNum in meanDict:
            numOfObjects = sumDict.get(classNum)[0]
            meanVector = meanDict.get(classNum)
            diffVector = np.subtract(meanVector, globalMean)
            diffVector = diffVector.reshape(self.NFEATURE, 1)
            varianceMatrix = np.dot(numOfObjects, np.dot(diffVector, np.transpose(diffVector)))
            betweenClassVariance = np.add(betweenClassVariance, varianceMatrix)
#}}}
        return betweenClassVariance


def printMatrix(matrix):
#{{{
    for row in range(0,len(matrix)):
        tempStr = ""
        for col in range(0,len(matrix[row])):
            tempStr += str(matrix[row][col]) + " "
        print tempStr
#}}}

def classMapping(flowerName):
#{{{
    if flowerName == "Iris-setosa":
        return 0
    elif flowerName == "Iris-versicolor":
        return 1
    elif flowerName == "Iris-virginica":
        return 2
    else :
        print "Flower Name Exception: unknown flower"
        return -1
#}}}

def readMatrix(filePath):
#{{{
    ## Exception handling for file opening
    try:
        IrisFile = open(filePath)
    except:
        print "Iris Data IO error, please check your input path"
    
    ## read in raw string, and store in temporary matrix (string only)
    tempList = []
    for tempStr in IrisFile: # read each line of IrisData
        tempStr = tempStr.replace("\n","")
        tempList.append( tempStr.split(",") )
    #printMatrix(tempList)

    ## now convert string to numeric value and store in another matrix IrisData
    Data = []
    for row in range(0,len(tempList)):
        temp = []
        if len(tempList[row]) < 5: ## encounter empty line
            break
        ## 0-3 features need direct conversion
        for col in range(0,4): 
            temp.append( float( tempList[row][col] ) )
        ## 4th feature need particular mapping
        temp.append( classMapping( tempList[row][4] ) )
        Data.append( temp )
    #printMatrix(IrisData)
#}}}
    return Data

def getSolutionOf_3_1_(IrisData, numOfFeatures=4 , PRINT = False):
    #{{{
    Xfisher = Fisher(IrisData, numOfFeatures)
    withinClassVariance = Xfisher.getWithinClassVariance()
    withinClassVarianceInv = np.linalg.inv(withinClassVariance) ## get inverse
    betweenClassVariance = Xfisher.getBetweenClassVariance()
    varianceCombo = np.dot(withinClassVarianceInv, betweenClassVariance)
    eigenValue, eigenVector = np.linalg.eig(varianceCombo)
    if PRINT:
        print "within-Class Scatter Matrix(Sw):"
        print withinClassVariance
        print "between-Class Scatter Matrix(SB):"
        print betweenClassVariance
        print "inv(Sw)*SB:"
        print varianceCombo
        print "eigen values:"
        print eigenValue
        print "matrix normalized eigen Vectors (W)"
        print eigenVector
        #print np.transpose(eigenVector)
        #}}}
    return withinClassVariance, betweenClassVariance, eigenValue, eigenVector

def getSolutionOf_3_2_(IrisData, eigenValue, eigenVector, numOfFeatures=4, PRINT = False):
#{{{
    originalData = np.asarray(IrisData)
    originalInput = originalData[:,0:numOfFeatures]
    originalLabel = originalData[:,numOfFeatures]
    originalLabel = originalLabel.reshape(len(originalLabel),1)
    ## get matrix W as the eigenVector with 2 largest eigenValue
    W = eigenVector[:,0:2]
    ## remove the img part
    W = np.array(W, dtype=np.float32)
    ## get the projected feature data
    mappedInput = np.dot(originalInput, W)
    mappedData = np.append(mappedInput, originalLabel, axis = 1)

    if PRINT:
        ## (a) Report the two eigenvalues and eigenvectors found.
        print "SOLUTION for _3_2_:"
        print "eigenValue_1:", np.real(eigenValue[0]), " eigenVector_1:", np.array(eigenVector[:,0], dtype=np.float32)
        print "eigenValue_2:", np.real(eigenValue[1]), " eigenVector_2:", np.array(eigenVector[:,1], dtype=np.float32)
        ## (c) ratio of the two eigenvalues found
        print "ratio of eigenValue:", np.real(eigenValue[0])/np.real(eigenValue[1])

    ## (b) Provide a plot of the projected data using different colours for each class.
    pl.plot(mappedInput[0:50,0],mappedInput[0:50,1],'ro', label="Iris-setosa")
    pl.plot(mappedInput[50:100,0],mappedInput[50:100,1],'go', label="Iris-versicolor")
    pl.plot(mappedInput[100:150,0],mappedInput[100:150,1],'bo', label="Iris-virginica")
    pl.title("Projected Data")
    pl.xlabel("Dimension with Largest EigenValue")
    pl.ylabel("Dimension with Second Largest EigenValue")
    pl.legend(loc=9)
    pl.draw()
#}}}
    return mappedData

def getSolutionOf_3_3_(projectedData, PRINT=False):
#{{{
    Yfisher = Fisher(projectedData, numOfFeatures=2)
    withinClassVariance = Yfisher.getWithinClassVariance()
    withinClassVarianceInv = np.linalg.inv(withinClassVariance) ## get inverse
    betweenClassVariance = Yfisher.getBetweenClassVariance()
    varianceCombo = np.dot(withinClassVarianceInv, betweenClassVariance)
    J = np.trace(varianceCombo)
    if PRINT:
        print "Solution for _3_3_"
        print "within-Class Scatter Matrix(Sw):"
        print withinClassVariance
        print "between-Class Scatter Matrix(SB):"
        print betweenClassVariance
        print "inv(Sw)*SB:"
        print varianceCombo
        print "criteria J:trace of inv(Sw)*SB"
        print "    ", J
#}}}
    return J

def getSolutionOf_3_4_(IrisData, numOfFeatures=4, PRINT=False):
#{{{
    nameDict = {1:"Sepal Length", 2:"Sepal Width", 3:"Petal Length", 4:"Petal Width"}
    allCombos = [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
    JList = []
    originalData = np.asarray(IrisData)
    originalLabel = originalData[:,-1]
    originalInput = originalData[:,0:numOfFeatures]

    numOfObjects = len(originalData)
    for combo in allCombos:
        projectedData = np.append(originalInput[:,combo[0]].reshape(numOfObjects, 1), originalInput[:,combo[1]].reshape(numOfObjects, 1), axis=1)
        projectedData = np.append(projectedData, originalLabel.reshape(numOfObjects, 1), axis=1)
        JList.append((combo[0]+1, combo[1]+1, getSolutionOf_3_3_(projectedData)))
    if PRINT:
        print "Solution of _3_4_"
        print "List of criteria from different projection to axe"
        for each in JList:
            print (nameDict.get(each[0]),nameDict.get(each[1])) , each[2]
#}}}
    return JList

def main():
    ## Data import to memory
    IrisDataFile = "./bezdekIris.data.txt"
    IrisData = readMatrix(IrisDataFile)

    ##printMatrix(IrisData)
    WCV, BCV, eigenValue, eigenVector = getSolutionOf_3_1_(IrisData, 4, PRINT=True)
    projectedData = getSolutionOf_3_2_(IrisData, eigenValue, eigenVector, 4, PRINT=True)
    getSolutionOf_3_3_(projectedData, PRINT=True)
    getSolutionOf_3_4_(IrisData,4,PRINT=True)
    pl.show()

if __name__ == "__main__":
    warnings.simplefilter("ignore")
    main()
