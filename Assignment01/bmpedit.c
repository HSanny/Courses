/** 
* @file bmpedit.c 
* @version 1.4
* @since 2013-02-28
* @author Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
* ***********************************************
*     Â© 2013, Jimmy Lin 
*    ALL RIGHTS RESERVED. 
* ***********************************************
* Description:
*  	Reads header information from Windows BMP files and can apply simple image filters.
* 	Details see at http://cs.anu.edu.au/courses/COMP2300/assignment1.html
* Reference:
*   http://en.wikipedia.org/wiki/BMP_file_format
*
* Edited by MacVim
* Info auto-generated by Snippet 
* */

/* Include list and constant list*/
/*{{{*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define true 1;
#define false 0;

#define INPUT_IMAGE_HEADER_DISPLAY 0;
#define OUTPUT_IMAGE_HEADER_DISPLAY 1;
/*}}}*/

/* Type definition and structure */
typedef int bool;
struct pixel{
/*{{{*/
    int blue;
    int green;
    int red;
    float mean;  // this item is for test
    int offset;
/*}}}*/
};
struct header{
/*{{{*/
    // members below are included in the real file
    unsigned char headerField [3];
    unsigned int sizeOfFile;
    unsigned int offsetOfImageData;
    unsigned int headerLength;
    signed int widthInPixels;
    signed int heightInPixels;
    unsigned int numColorPlane;
    unsigned int bitsPerPixels;
    unsigned int compression;
    unsigned int sizeOfImage;
    signed int horizontalResolution;
    signed int verticalResolution;
    unsigned int numOfColors;
    // members below are calculated based on information from real file
    int rowSize;
    int arraySize;
/*}}}*/
};

/* Prototype of Function */
/*{{{*/
struct pixel *pixelRead(FILE * inFile, int start);
void copyPixel(struct pixel * dest, struct pixel * src);
void printHeader(int SWITCH, struct header * HD,char * title);
struct header *readHeader(FILE * inFile);
void writeHeader(FILE * outFile, struct header * newHD);
void printMatrixOfPixel(int SWITCH, struct pixel ** matrixOfPixel, int heightInPixels,int widthInPixels);
void readBitMap(FILE * inFile, struct header *HD, struct pixel **dest);
void writeBitMap(FILE * outFile, struct pixel ** MatrixOfPixel, struct header * HD);
void filterBitMap(struct header *HD,struct pixel ** rawMatrixOfPixel,struct pixel ** filteredMatrixOfPixel, float THRESHOLD);
void cropBitMap(struct header * HD,struct pixel **src,struct header *newHD,struct pixel **dest,int leftmost_x, int downmost_y);
void rotateBitMap(struct pixel **src, struct header *newHD,struct pixel ** dest, int degree);
void blurBitMap(struct pixel **src, struct header *newHD,struct pixel ** dest, int WINDOWSIZE);
struct pixel **newMatrixOfPixel(struct header * HD);
void copyMatrixOfPixel(struct pixel ** src, struct pixel ** dest, int height, int width);
void printMatrixOfPixel(int SWITCH, struct pixel ** matrixOfPixel, int heightInPixels,int widthInPixels);
/*}}}*/

/* Byte-level manipulation:
 *  - read signed integer: getSignedInt 
 *  - read unsigned integer: getUnsignedInt 
 *  - read short integer: getShortInt 
 * *//*{{{*/
signed int getSignedInt(FILE *inFile, int start )
{
    signed int x;
    fseek(inFile,start,SEEK_SET);
	fread(&x,sizeof(signed int),1,inFile);
    return x;
}
unsigned int getUnsignedInt(FILE *inFile, int start)
{
    unsigned int x;
    fseek(inFile,start,SEEK_SET);
	fread(&x,sizeof(unsigned int),1,inFile);
    return x;
}
short getShortInt(FILE *inFile, int start)
{
    short int x;
    fseek(inFile, start,SEEK_SET);
    fread(&x,sizeof(short),1,inFile);
    return x;
}/*}}}*/

/* Pixel_level: read from file to memory */
struct pixel *pixelRead(FILE * inFile, int start){
/*{{{*/
    unsigned char BLUE,GREEN,RED;
    fseek(inFile, start, SEEK_SET);
    fread(&BLUE, sizeof(char), 1, inFile);
    fread(&GREEN, sizeof(char), 1, inFile);
    fread(&RED, sizeof(char), 1, inFile);
    
    struct pixel * p;
    p = ( struct pixel*) malloc(sizeof(struct pixel));
    p->blue = BLUE ;
    p->green = GREEN ;
    p->red = RED ;
    p->offset = start;
    //printf(" (%d:%d %d %d) \n",start,BLUE,GREEN,RED);
 /*}}}*/
    return p;
}

/* Copy content of pixel stucture from src to dest */
void copyPixel(struct pixel * dest, struct pixel * src){
/*{{{*/
    dest->blue = src->blue;
    dest->red = src->red;
    dest->green = src->green;
    dest->offset = src->offset;
    dest->mean = src->mean;
/*}}}*/
    return ;
}

/* Image-level: Read image information to memory 
 *   - Decode for Bitmap file header (restore in HD structure) 
 *   - Decode for DIB header (restore in HD structure)
 *   - Print basic information
 * */
struct header *readHeader(FILE * inFile)
{
/*{{{*/
    struct header *HD;
    HD = (struct header *) malloc (sizeof(struct header));
    /* Decode for Bitmap file header */
    fseek(inFile,0x00,SEEK_SET);
    HD->headerField[0] = fgetc(inFile); 
    HD->headerField[1] = fgetc(inFile);
    HD->headerField[2] = '\0';
    HD->sizeOfFile = getUnsignedInt(inFile,0x02);
    HD->offsetOfImageData = getUnsignedInt(inFile,0x0A);

    /* Decode for DIB header */
    HD->headerLength = getUnsignedInt(inFile,0x0E);
    HD->widthInPixels = getSignedInt(inFile,0x12);
    HD->heightInPixels = getSignedInt(inFile,0x16);
    HD->numColorPlane = getShortInt(inFile,0x1A) ; // short int
    HD->bitsPerPixels = getShortInt(inFile,0x1C) ; // short int
    HD->compression = getUnsignedInt(inFile,0x1E);
    HD->sizeOfImage = getUnsignedInt(inFile,0x22);
    HD->horizontalResolution = getSignedInt(inFile,0x26);
    HD->verticalResolution = getSignedInt(inFile,0x2A);
    HD->numOfColors = getUnsignedInt(inFile,0x2E);
    HD->rowSize = ( (int)((HD->bitsPerPixels * HD->widthInPixels + 31)/ 32) ) * 4;
    HD->arraySize = HD->rowSize * HD->heightInPixels;
   
    /* Ouptut basic information of the header just acquired */
    bool input_image_header_display = INPUT_IMAGE_HEADER_DISPLAY;
    printHeader(input_image_header_display,HD,"Header of input bmp"); 
/*}}}*/
	return HD;
}

void writeHeader(FILE * outFile, struct header * newHD){
/*{{{*/
    int i,j;
    /* Write Bitmap file header to new bmp file */
    fseek(outFile,0x00,SEEK_SET);

    fwrite(newHD->headerField,sizeof(unsigned char), 2, outFile) ; //header field: BM
    fwrite(&(newHD->sizeOfFile),sizeof(unsigned int), 1, outFile); //size of file
    fseek(outFile,0x0A,SEEK_SET);
    fwrite(&(newHD->offsetOfImageData),sizeof(unsigned int), 1, outFile); // image data start index

    /* Write DIB header to new bmp file */
    fwrite(&(newHD->headerLength),sizeof(unsigned int), 1, outFile);
    fwrite(&(newHD->widthInPixels),sizeof(signed int), 1, outFile);
    fwrite(&(newHD->heightInPixels),sizeof(signed int), 1, outFile);
    fwrite(&(newHD->numColorPlane),sizeof(short int), 1, outFile);
    fwrite(&(newHD->bitsPerPixels),sizeof(short int), 1, outFile);
    fwrite(&(newHD->compression),sizeof(unsigned int), 1, outFile);
    fwrite(&(newHD->sizeOfImage),sizeof(unsigned int), 1, outFile);
    fwrite(&(newHD->horizontalResolution),sizeof(signed int), 1, outFile);
    fwrite(&(newHD->verticalResolution),sizeof(signed int), 1, outFile);
    fwrite(&(newHD->numOfColors),sizeof(unsigned int), 1, outFile);
/*}}}*/
    return ;
}

void printHeader(int SWITCH, struct header * HD,char * title){
/*{{{*/
    if (SWITCH){
    printf("--------------%s---------------\n",title);
    printf("|File Header:\n");
    printf("|\tHeader Field: %s \n", HD->headerField);
    printf("|\tSize of File: %d \n", HD->sizeOfFile);
    printf("|\tOffset of Image Data: %d \n", HD->offsetOfImageData);
    printf("|DIB Header:\n");
    printf("|\tHeader Length: %d \n", HD->headerLength);
    printf("|\tWidth in Pixels: %d \n", HD->widthInPixels);
    printf("|\tHeight in Pixels: %d \n" ,HD->heightInPixels);
    printf("|\tColor planes being used: %d \n", HD->numColorPlane);
    printf("|\tBits per pixels: %d \n", HD->bitsPerPixels);
    printf("|\tCompression Method: %d \n",HD->compression);
    printf("|\tSize of raw bitmap data: %d \n", HD->sizeOfImage);
    printf("|\tHorizental Resolution: %d \n",HD->horizontalResolution);
    printf("|\tVertical Resolution: %d \n", HD->verticalResolution);
    printf("|\tColors in Palette: %d \n",HD->numOfColors);
    printf("|Calculated Params:\n");
    printf("|\tRow Size with paddling: %d \n",HD->rowSize);
    printf("|\tArray Size of Bitmap Image: %d \n",HD->arraySize);
    printf("----------------------------------------------\n");
    }
/*}}}*/
    return ;
}

void readBitMap(FILE * inFile, struct header *HD, struct pixel **dest  ){
/*{{{*/
    /* Handle with interface */
    int bitsPerPixels = HD->bitsPerPixels;
    int heightInPixels = HD->heightInPixels;
    int widthInPixels = HD->widthInPixels;

    /* Initialization */
    int rowSize = HD->rowSize;
    int i,j;

    /* Decode for every pixel */
    for ( i = 0; i < heightInPixels ; i++) 
        for (j = 0; j < widthInPixels ; j++ )
           *(dest+ i* widthInPixels + j) = pixelRead(inFile,0x36+rowSize*i +3*j);
    /*}}}*/
    return ;
}

void writeBitMap(FILE * outFile, struct pixel ** MatrixOfPixel, struct header * HD){
/*{{{*/
    unsigned char * tempChar;
    // application for memory avoids bus errors...
    tempChar = (char *) malloc(1);
    int i,j,k;
    /* Synchornize the start point of bitmap data.. */
    fseek(outFile,HD->offsetOfImageData,SEEK_SET);
    
    /*  Start to export BITMAP data */
    unsigned char R,G,B;
    unsigned char paddle = '\00';
    int numOfPadding = HD->rowSize - HD->widthInPixels * 3;
    struct pixel * tempPixel;
    for (i = 0; i < HD->heightInPixels; i++) {
        for (j = 0; j< HD->widthInPixels; j++ ){
            /* pixel output */
            tempPixel = *(MatrixOfPixel + i*(HD->widthInPixels) + j);
            R = tempPixel->red;
            B = tempPixel->blue;
            G = tempPixel->green;
            /* Ordering of fwrite does matter, attention please.. */
            fwrite(&B,sizeof(unsigned char), 1, outFile);
            fwrite(&G,sizeof(unsigned char), 1, outFile);
            fwrite(&R,sizeof(unsigned char), 1, outFile);
        }
        /* paddle output */
        for (k = 0; k < numOfPadding; k ++)
            fwrite(&paddle,sizeof(unsigned char), 1, outFile);
    }
/*}}}*/
    return;
}
void filterBitMap(struct header *HD,struct pixel ** rawMatrixOfPixel,struct pixel ** filteredMatrixOfPixel, float THRESHOLD){
/*{{{*/
    /* Handle with interface */
    int bitsPerPixels = HD->bitsPerPixels;
    int heightInPixels = HD->heightInPixels;
    int widthInPixels = HD->widthInPixels; 

    int i,j,k;
    float meanValue;
    int R,G,B;
    struct pixel * p; // pointer for rawMatrixOfPixel
    struct pixel *temp; // pointer for filteredMatrixOfPixel
    for (i = 0; i < heightInPixels ; i++)
        for (j = 0; j < widthInPixels ; j ++){
            p = *(rawMatrixOfPixel + widthInPixels*i + j);
            temp = *(filteredMatrixOfPixel + widthInPixels*i + j); 
            R = p -> red;
            G = p -> green;
            B = p -> blue;
            meanValue = (R + G + B) / (255.0 * 3.0);
            //printf("%.3f \n",meanValue);
            if (meanValue >= THRESHOLD) {
                temp -> red = 255;
                temp -> green = 255;
                temp -> blue = 255;
            }else{
                temp -> red = 0;
                temp -> green = 0;
                temp -> blue = 0;
            }
            temp->mean = meanValue;
            temp->offset = p->offset;
        }
/*}}}*/
    return ;
}

void cropBitMap(struct header * HD,struct pixel **src,struct header *newHD,struct pixel **dest,int leftmost_x, int downmost_y){
/*{{{*/
    int i,j;
    struct pixel *srcp, *destp;
    int oldHeight = HD->heightInPixels, oldWidth = HD->widthInPixels;
    int newHeight = newHD->heightInPixels, newWidth = newHD->widthInPixels;
    //printf("%d:%d\n",newHeight,newWidth);

    for (i = 0; i < newHeight; i++)
        for (j = 0; j < newWidth; j++){
            srcp = *(src + (i + downmost_y) * oldWidth + (leftmost_x + j));
            destp = *(dest + i * newWidth + j);
            copyPixel(destp,srcp); 
        }/*}}}*/
    return ;
}

void rotateBitMap(struct pixel **src, struct header *newHD,struct pixel ** dest, int degree) {
/*{{{*/
    int i,j;
    struct pixel * srcp;
    struct pixel *destp;
    int normalDegree;
    if ( degree >= 0 )
        normalDegree = degree % 360;
    else 
        normalDegree = (0 - degree) % 360;
    //printf("normal degree: %d\n",normalDegree);
    
    int oldHeight = newHD->heightInPixels, oldWidth = newHD->widthInPixels;
    int tempStore;
    if (normalDegree == 90 || normalDegree == 270){
        // swap value between height and width to get new header
        tempStore = newHD->heightInPixels;
        newHD->heightInPixels = newHD->widthInPixels;
        newHD->widthInPixels = tempStore;
        // swap value bettween vertical and horizontal Resolution
        tempStore = newHD->verticalResolution;
        newHD->verticalResolution = newHD->horizontalResolution;
        newHD->horizontalResolution = tempStore;
        // update value of rowSize for paddling and arraySize for calculating size of file
        newHD->rowSize = ((newHD->bitsPerPixels * newHD->widthInPixels + 31) /32) * 4;
        newHD->arraySize = newHD->rowSize * newHD->heightInPixels;
    }
    /* To improve performance, use more local memory (space complexity) to reduce time complexity */
    int newHeight = newHD->heightInPixels, newWidth = newHD->widthInPixels;
    //printf("%d,%d\n",newHeight,newWidth);
    //printf("%d,%d\n",oldHeight,oldWidth);

    /* Assign content of pixel from old matrix to new matrix */
    for (i = 0; i < newHeight; i ++){
        for (j = 0; j < newWidth; j++){
             if (normalDegree == 90){
                srcp = *(src + j*oldWidth + oldWidth - i - 1);
                destp = *(dest + i*newWidth + j);
                //printf("(%d,%d)->(%d,%d)\n",j,(oldWidth-i-1),i,j);
             } else if (normalDegree == 180) {
                srcp = *(src + oldHeight * oldWidth - i*oldWidth - j - 1);
                destp = *(dest + i*newWidth + j);
             } else if (normalDegree == 270) {
                srcp = *(src + (oldHeight - j - 1)*oldWidth + i);
                destp = *(dest + i*newWidth + j);
             } else if (normalDegree == 0) {
                srcp = *(src + i*oldWidth + j);
                destp = *(dest + i*newWidth + j);
             } else { 
                printf("degree Unavailable..\n");

                return ;
             }
            copyPixel(destp,srcp);
        }
    }
/*}}}*/
    return ;
}

void blurBitMap(struct pixel **src, struct header *newHD,struct pixel ** dest, int WINDOWSIZE) {
/*{{{*/
    int i,j;
    int width = newHD->widthInPixels;
    int height = newHD->heightInPixels;

    for (i = 0; i < width ; i++){
        for (j = 0; j < height; j ++) {
            // set the blur boundary
            int left, right, up, down;
            left = (i - WINDOWSIZE < 0) ? 0 : (i - WINDOWSIZE);
            right = (i + WINDOWSIZE > width - 1) ? (width - 1): (i + WINDOWSIZE);
            down = (j - WINDOWSIZE < 0)? 0 : (j - WINDOWSIZE);
            up = (j + WINDOWSIZE > height - 1)? (height - 1) : (j + WINDOWSIZE);
            // start bluring
            int sumRed = 0, sumBlue = 0, sumGreen = 0, sumPixels = 0;
            int x, y;
            struct pixel * temp;
            for (x = left; x < right; x++) {
                for (y = down; y < up; y ++) {
                    temp = *(src + y * width + x);
                    sumRed += temp -> red;
                    sumBlue += temp -> blue;
                    sumGreen += temp -> green;
                    sumPixels ++;
                }
            }
            int meanRed = sumRed / sumPixels;
            int meanBlue = sumBlue / sumPixels;
            int meanGreen = sumGreen / sumPixels;
            struct pixel * destTemp = *(dest + j * width + i);
            destTemp -> red = meanRed;
            destTemp -> blue = meanBlue;
            destTemp -> green = meanGreen;
        }
    }
/*}}}*/
    return ;
}

struct pixel **newMatrixOfPixel(struct header * HD){
/*{{{*/
    int k,j;
    struct pixel **newMatrix;
    struct pixel *temp;
    newMatrix = (struct pixel **)malloc(HD->widthInPixels*HD->heightInPixels * sizeof(struct pixel *));
    for (k = 0 ; k < HD->heightInPixels; k ++) // loop over row
        for (j = 0 ; j < HD->widthInPixels; j++){ // loop over colomn
            temp = (struct pixel *) malloc (sizeof(struct pixel));
            *(newMatrix + (HD->widthInPixels)*k + j) = temp;
            }
/*}}}*/
    return newMatrix;
}

void copyMatrixOfPixel(struct pixel ** src, struct pixel ** dest, int height, int width){
/*{{{*/
    int i,j;
    struct pixel * srcp;
    struct pixel * destp;
    for (i = 0 ; i < height; i ++)
        for (j = 0 ; j < width ; j++){
            srcp = *(src + i * width + j);
            destp = * (dest + i * width + j);
            copyPixel(destp,srcp);
        }
/*}}}*/
    return;
}


int main(int argc, char *argv[])
{
    /* parameter recognition */
/*{{{*/
    // initialization and set default values to parameters
	int i = 1;
    int numOfArgs = 0;
    bool OUTPUT_SPECIFIED = false;
    bool FILTER_MODE = false;
    bool CROPPING_MODE = false;
    bool ROTATION_MODE = false;
    bool BLENDING_MODE = false;
    bool RESIZING_MODE = false;
    bool BLUR_MODE = false;
    char OUTPUTPATH [100] = "./result.bmp";// file name at most 100 characters 
    double THRESHOLD = 0.2;
    int degree_of_rotation = 0;
    int WINDOWSIZE = 5;

    // parameter below depends on file header (set default latter)
    int HEIGHT_AFTER_CROP ,WIDTH_AFTER_CROP, LEFTMOST_COLUMN_FOR_CROP, DOWNMOST_ROW_FOR_CROP;

	char* help_info = "\n\
    mode    Param                Usage Details\n\
    -o      FILE        Sets the output file for modified images \n\
    -t     0.0-1.0      Sets the THRESHOLD to filter the image through \n\
    -c                  Four parameters are compulsory as shown below  \n\
            Width       Width of cropped image (in pixels) \n\
            Height      Height of cropped image (in pixels) \n\
             X          x-position of the leftmost remained pixel after being cropped \n\
             Y          y-position of the remained bottom pixel after being cropped \n\
    -r      degree      Degree of rotation (positive if clockwise and must be multiple of 90) \n\
    -b     windowSize        Blur processing \n\
    -h		         Displays this usage message \n\
    \n";

	while(i < argc) {
		if (strcmp(argv[i],"-h") == 0){
			printf("%s",help_info);
			i++;
            numOfArgs ++;
		}
		else if (strcmp(argv[i],"-o") == 0){
            /* Specify the output file directory and name (default if not received) 
             *  Only take one more argument: output path
             * */
            OUTPUT_SPECIFIED = true;
            strcpy(OUTPUTPATH,argv[i+1]); 
			i += 2;
            numOfArgs ++;
		}
		else if (strcmp(argv[i],"-t") == 0){
            /* Threshold filtering mode  
             *  Take one more argument: THRESHOLD value
             * */
            char * ptr;
            FILTER_MODE = true;
            THRESHOLD = strtod(argv[i+1],&ptr);
			i += 2;
            numOfArgs ++;
		}
        else if (strcmp(argv[i],"-r") == 0){
            /* Rotation mode takes 1 argument: degree of rotation */
            char * ptrp;
            ROTATION_MODE = true;
            degree_of_rotation = (int) strtod(argv[i+1],&ptrp);
            printf("degree:%d\n",degree_of_rotation);
            if (degree_of_rotation % 90 != 0) {
                printf("Input angle is not orthogonal..\nSystem Exit\n");
                exit(1);
            }
            i += 2;
            numOfArgs ++;
        }
        else if (strcmp(argv[i],"-b") == 0){
            BLUR_MODE = true;
            WINDOWSIZE = atoi(argv[i+1]);
            i += 2;
            numOfArgs ++;
        }
        else if (strcmp(argv[i],"-c") == 0){
            /* Cropping mode 
             * Four arguments are required:
             *    - Height in pixel
             *    - Width in pixel
             *    - leftmost X-coordinate in pixels
             *    - downmost Y-coordinate in pixels
             * */
            if ( i + 4 < argc - 1) {
                // the argc-1 th argument is input bmp filepath
                CROPPING_MODE = true;
                WIDTH_AFTER_CROP = atoi(argv[i+1]);
                HEIGHT_AFTER_CROP = atoi(argv[i+2]);
                LEFTMOST_COLUMN_FOR_CROP = atoi(argv[i+3]);
                DOWNMOST_ROW_FOR_CROP = atoi(argv[i+4]);
                numOfArgs += 4;
                i += 4;
            } else {
                printf("Cropping an image requires 4 arguments (in order): \n\t- Height after cropping\n\t- Width after cropping\n\t- Leftmost column as first reserved column\n\t- Downmost row as first reserved row");
                exit(0);
            }
        }
        else i++;
    }
/*}}}*/

     /* Start Processing when:
     *  - the last argument includes .bmp suffix 
     *      and
     *  - the second last argument is not "-o"
     * */
    if (strstr(argv[argc-1],".bmp") != NULL && strcmp(argv[argc-2],"-o") != 0) {
        /* Open the binary image file */
        FILE * inFile = NULL;
        inFile = fopen(argv[argc-1],"rb");
        if (inFile == NULL){
            printf("Cannot open the specified input image: %s \nSystem exit..\n",argv[argc-1]);
            exit(1); //abnormal exit
        } else
            printf("\nFile opened: %s..\n", argv[argc-1]);

        /* Read the header of BMP file, including file header and DIB header */
        struct header *HD;
	    HD = readHeader(inFile);	
        printf("File Header for input image Created..\n");
        
        /* Verify the input arguments after reading original bitmap */
/*{{{*/
        if (FILTER_MODE){
            if (THRESHOLD > 1.0 || THRESHOLD < 0.0) {
                printf("The threshold is invalid .. Please make it within interval [ 0.0, 1.0]..\n");
                printf("System exit...");
                exit(1); // abnormal exit
            }
        }
        if (CROPPING_MODE) {
            HEIGHT_AFTER_CROP ,WIDTH_AFTER_CROP, LEFTMOST_COLUMN_FOR_CROP, DOWNMOST_ROW_FOR_CROP;
            /* verification for width after processing being overflowed */
            if (WIDTH_AFTER_CROP + LEFTMOST_COLUMN_FOR_CROP > HD->widthInPixels) {
                printf("Unsuccessful processing: invalid input argument \n");
                printf("\tCropping width overflowed, %d + %d > %d..\n",WIDTH_AFTER_CROP,LEFTMOST_COLUMN_FOR_CROP, HD->widthInPixels  );
                exit(0);
            }
            /* verification for height after processing being overflowed */
            if (HEIGHT_AFTER_CROP + DOWNMOST_ROW_FOR_CROP > HD->heightInPixels) {
                printf("Unsuccessful processing: invalid input argument \n");
                printf("\tCropping height overflowed, %d + %d > %d..\n",HEIGHT_AFTER_CROP, DOWNMOST_ROW_FOR_CROP, HD->heightInPixels);
                exit(0);
            }
        }
        printf("Arguments verified to be valid..\n");
/*}}}*/

        /* initilize for new file's header: newHD */
        /*{{{*/
        struct header *newHD; 
        newHD = (struct header *) malloc (sizeof (struct header)); 
        newHD->headerField[0] = HD->headerField[0];
        newHD->headerField[1] = HD->headerField[1];
        newHD->headerField[2] = HD->headerField[2];
        newHD->offsetOfImageData = HD->offsetOfImageData;
        newHD->headerLength = HD->headerLength;
        newHD->numColorPlane = HD->numColorPlane;
        newHD->bitsPerPixels = HD->bitsPerPixels;
        newHD->compression = HD->compression;
        newHD->horizontalResolution = HD->horizontalResolution;
        newHD->verticalResolution = HD->verticalResolution;
        newHD->numOfColors = HD->numOfColors;
        newHD->sizeOfImage = HD->sizeOfImage;
        newHD->sizeOfFile = HD->sizeOfFile;
        newHD->widthInPixels = HD->widthInPixels;
        newHD->heightInPixels = HD->heightInPixels;

        newHD->rowSize = HD->rowSize;
        newHD->arraySize = HD->arraySize;
        printf("File Header for output image Created..\n");
/*}}}*/

        /* Declaration and Initialization for memory */
/*{{{*/
        struct pixel **rawMatrixOfPixel;
        struct pixel **filteredMatrixOfPixel;
        struct pixel **croppedMatrixOfPixel;
        struct pixel **rotatedMatrixOfPixel;
        struct pixel **bluredMatrixOfPixel;
        struct pixel **resultedMatrixOfPixel;
        struct pixel *temp;
        /*}}}*/

        /* Get original matrix of pixels */
        rawMatrixOfPixel = newMatrixOfPixel(HD);
        readBitMap(inFile,HD,rawMatrixOfPixel); 
        resultedMatrixOfPixel = rawMatrixOfPixel;

        /* Get filtered matrix of pixels */
        if (FILTER_MODE){
/*{{{*/
            // Filter mode does not involve in the change of header structure
            filteredMatrixOfPixel = newMatrixOfPixel(HD);
            filterBitMap(HD,rawMatrixOfPixel,filteredMatrixOfPixel,THRESHOLD);
            printf("Filtering Processed with threshold %.3f\n",THRESHOLD);
            resultedMatrixOfPixel = filteredMatrixOfPixel;
/*}}}*/
        }
        /* Get cropped matrix of pixels */
        if (CROPPING_MODE){
/*{{{*/
            // change the header structure for new matrix of pixels.
            newHD->widthInPixels = WIDTH_AFTER_CROP;
            newHD->heightInPixels = HEIGHT_AFTER_CROP;
            newHD->rowSize = ((newHD->bitsPerPixels * newHD->widthInPixels + 31) /32) * 4;
            newHD->arraySize = newHD->rowSize * newHD->heightInPixels;
            newHD->sizeOfImage = newHD->rowSize * newHD->heightInPixels;
            newHD->sizeOfFile = newHD->offsetOfImageData + newHD->sizeOfImage;

            croppedMatrixOfPixel = newMatrixOfPixel(newHD);
            cropBitMap(HD,resultedMatrixOfPixel,newHD,croppedMatrixOfPixel,LEFTMOST_COLUMN_FOR_CROP, DOWNMOST_ROW_FOR_CROP);
            printf("Cropping Processed with: \n");
            printf("\tWIDTH_AFTER_CROP:%d \n\tHEIGHT_AFTER_CROP:%d \n", WIDTH_AFTER_CROP, HEIGHT_AFTER_CROP);
            printf("\tLEFTMOST_COLUMN_FOR_CROP:%d \n\tDOWNMOST_ROW_FOR_CROP:%d \n", LEFTMOST_COLUMN_FOR_CROP, DOWNMOST_ROW_FOR_CROP);
            resultedMatrixOfPixel = croppedMatrixOfPixel;
/*}}}*/
        }
        if (ROTATION_MODE){
/*{{{*/
            rotatedMatrixOfPixel = newMatrixOfPixel(newHD); // size unchanged
            rotateBitMap( resultedMatrixOfPixel, newHD, rotatedMatrixOfPixel ,degree_of_rotation);
            resultedMatrixOfPixel = rotatedMatrixOfPixel;
/*}}}*/
        } 
        if (BLUR_MODE) {
            bluredMatrixOfPixel = newMatrixOfPixel(newHD);
            blurBitMap( rawMatrixOfPixel, newHD, bluredMatrixOfPixel, WINDOWSIZE);
            resultedMatrixOfPixel = bluredMatrixOfPixel;
        }
        /* Open output image file */
        FILE * outFile = NULL;
        bool output_image_header_display = OUTPUT_IMAGE_HEADER_DISPLAY;
        outFile = fopen(OUTPUTPATH,"wb+");
        if (outFile == NULL) {
            printf("Cannot open the specified output image file: %s \n Please check directory.. System exit..\n",OUTPUTPATH);
            exit(1); //abnormal exit
        }

        /* Export the filtered matrix to external bmp file */
        writeHeader(outFile, newHD);
        printHeader(output_image_header_display,newHD,"Header of Output Image");
        //printf("Before write file: \n Height:%d Width:%d\n",newHD->heightInPixels,newHD->widthInPixels);
        writeBitMap(outFile, resultedMatrixOfPixel, newHD);
        printf("Objective bmp file:  %s  exported..\n", OUTPUTPATH);

        /* Close the binary image file */
        if (fclose(inFile) == 0 && fclose(outFile) == 0) {
            printf("IN & OUT files closed..\n");
        } else {
            printf("Cannot close IN & OUT file...\n"); }
        printf("BMP processed succeed..\n");
	    }
	exit(0); // normally quit from program.. 
    
}

