''' 
    Filename:   EM.py    
    Version:    1.5
    Since:      2013-04-23
    Author: 
        Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
        
    Edited by MacVim
    Documentation auto-generated by Snippet 
'''
import numpy as np
import Gaussian as gau
import random
def factoryMixtureGaussians(mixtures, dimensions):
    '''
    Create a set of gaussian distribution with parameters all zeros
    Parameters:
        - mixtures, the number of gaussian distribution used
            in the mixture model
    return:
        - gaussians, a list of gaussian object
    '''
    gaussians = []
    for i in range(0, mixtures):
        tempGaussian = gau.Gaussian(i, dimensions)
        gaussians.append(tempGaussian)
    return gaussians

def randomInitialise(patterns, gaussians):
    '''
    Randomly initialise its parameters.
    parameter:
        - gaussians, a list of gaussian distribution to be randomly
            initialised in given model.
    No return value
    '''
    numOfComponents = len(gaussians)
    numOfFeatures  = patterns.shape[1]
    piList = np.zeros(numOfComponents)
    MinPattern = np.min(patterns, axis = 0)
    MaxPattern = np.max(patterns, axis = 0)
    MeanPattern = np.mean(patterns, axis = 0)
    '''
    for i in range(0, numOfComponents):
        gaussians[i].initialise(MaxPattern, MinPattern)
        if i < numOfComponents - 1:
            low = 0.0
            high = 1 - sum(piList)
            piList[i] = random.triangular(low, high)
        else:
            piList[i] = 1 - sum(piList)
    '''
    ##'''
    for i in range(0, numOfComponents):
        tempGaussian = gaussians[i]
        tempMu = np.random.multivariate_normal( MeanPattern, np.identity(numOfFeatures) )
        tempGaussian.mu = np.asarray(tempMu).reshape((numOfFeatures, 1))
        tempGaussian.sigma = np.identity(numOfFeatures)
        ##tempGaussian.sigma = np.dot(0.5*random.random(), np.identity(numOfFeatures) )
        ##'''
    ## equally initialise
    ##piList = np.multiply(1.0/numOfComponents, np.ones((numOfComponents)))

    for i in range(0, numOfComponents):
        if i < numOfComponents - 1:
            high = 1 - sum(piList)
            piList[i] = high * random.random() 
        else:
            piList[i] = 1 - sum(piList)
    return piList

def expectation(patterns, gaussians, piList):
    dimensions = patterns.shape[1]
    numOfComponents = len(gaussians)
    assert numOfComponents == len(piList)
    responsibilities = []
    for tempPattern in patterns:
        tempPattern = tempPattern.reshape((dimensions, 1))
        tempResponsibilityList = []
        for i in range(0, numOfComponents):
            tempResonsibility = gaussians[i].evaluate(tempPattern) * piList[i]
            tempResponsibilityList.append(tempResonsibility)
        normResponsibility = sum(tempResponsibilityList)
        for i in range(0, numOfComponents):
            tempResponsibilityList[i] = tempResponsibilityList[i] / normResponsibility
        responsibilities.append(tempResponsibilityList)
    return np.asarray(responsibilities)

def maximisation(patterns, responsibilities, gaussians):
    numOfComponents = len(gaussians)
    numOfPatterns = patterns.shape[0]
    numOfFeatures = patterns.shape[1]
    assert responsibilities.shape[1] == numOfComponents
    meanOfPattern = np.mean(patterns, axis =0)
    for i in range(0, numOfComponents):
        tempGaussian = gaussians[i]
        ## initialise local variable
        accMu = np.zeros((1, numOfFeatures))
        accSigma = np.zeros((numOfFeatures, numOfFeatures))
        ## update pi first
        piList = np.mean(responsibilities, axis = 0)
        ## update mu first
        for j in range(0, numOfPatterns):
            effectiveMu = np.dot(responsibilities[j, i], patterns[j])
            accMu = np.add(accMu, effectiveMu)
        tempGaussian.mu = np.transpose(np.divide(accMu, piList[i]* numOfPatterns))
        ## finally update sigma
        for j in range(0, numOfPatterns):
            diffPatternMu = np.subtract(patterns[j].reshape((numOfFeatures,1)), tempGaussian.mu)
            tempSigma = np.dot(diffPatternMu, np.transpose(diffPatternMu))
            effectiveSigma = np.dot(responsibilities[j, i], tempSigma)
            accSigma = np.add(accSigma, effectiveSigma)
        tempGaussian.sigma = np.divide(accSigma, piList[i]*numOfPatterns)
    return gaussians, piList

def getCriteria( patterns, gaussians, piList, responsibilities):
    ## verify arguments
    assert len(gaussians) == len(piList)
    ## argument information
    numOfPatterns = patterns.shape[0]
    numOfFeatures = patterns.shape[1]
    numOfComponents = len(gaussians)
    ## initialise the local variable
    loglikelihood = 0
    expectedLoglikelihood = 0
    ## start to calculate criteria
    for i in range(0, numOfPatterns):
        tempPattern = patterns[i].reshape((numOfFeatures, 1))
        tempLikelihood = 0
        tempExpectedLikelihood = 0
        for j in range(0, numOfComponents):
            tempGaussian = gaussians[j]
            tempMixtureCoefficient = piList[j]
            tempJointProbability = tempMixtureCoefficient* tempGaussian.evaluate(tempPattern) 
            tempLikelihood += tempJointProbability 
            ## avoid numerical error
            if tempJointProbability == 0:
                tempExpectedLikelihood += responsibilities[i, j] * np.log(0.0000001)
            else:
                tempExpectedLikelihood += responsibilities[i, j]* np.log(tempJointProbability)
        loglikelihood += np.log(tempLikelihood)
        expectedLoglikelihood += tempExpectedLikelihood
    return loglikelihood, expectedLoglikelihood

