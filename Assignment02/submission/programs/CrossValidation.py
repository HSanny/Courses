''' 
    Filename:   CrossValidation.py    
    Version:    1.0
    Since:      2013-05-02
    Author: 
        Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
        
    Edited by MacVim
    Documentation auto-generated by Snippet 
'''
import numpy as np
import math
import Gaussian as gau
def shuffle(dataMatrix):
    ''' 
    The argument of this function is a matrix whose row includes
    the combination of the pattern and label. So that we can 
    shuffle them together. 
    '''
    shuffledDataMatrix = np.copy(dataMatrix)
    np.random.shuffle(shuffledDataMatrix)
    return shuffledDataMatrix

def getCrossValidationSet(k, cvtimes, DataMatrix, featureDimension, labelIndex):
    ## shuffle original input data matrix
    shuffledMatrix = shuffle(DataMatrix)
    numOfObjects = shuffledMatrix.shape[0]
    ## deal with the case when number of patterns is not multiple of k
    ## and add some more patterns in the last set..
    sizeOfEachSet = int(math.floor(numOfObjects / k ))
    sizeOfTrainingSet = sizeOfEachSet * (k - 1)
    sizeOfTestingSet = numOfObjects - sizeOfTrainingSet

    trainingSet =  shuffledMatrix[0:sizeOfTrainingSet, :]
    testingPatterns = shuffledMatrix[sizeOfTrainingSet:numOfObjects, 0:featureDimension]
    testingLabels = shuffledMatrix[sizeOfTrainingSet:numOfObjects, labelIndex]

    return trainingSet, testingPatterns, testingLabels

def groupMessyData(trainingSet, patternDimension, labelIndex):
    ## group training data 
    groupedTrainingSet = {}
    for tempObject in trainingSet:
        tempLabel = tempObject[labelIndex]
        tempPattern = tempObject[0:patternDimension]
        tempPattern = np.asarray([tempPattern])
        groupMembers = groupedTrainingSet.get(tempLabel)
        if groupMembers is None:
            groupedTrainingSet.update({tempLabel:tempPattern})
        else:
                groupMembers = np.concatenate((groupMembers, tempPattern), axis= 0)
                groupedTrainingSet.update({tempLabel: groupMembers})
    return groupedTrainingSet

def getPrediction(testingPatterns, gaussians):
    ## validate by tranversing the whole testing set
    prediction = []
    for tempTestPattern in testingPatterns:
        conditionalProb = []
        for tempGaussian in gaussians:
            tempProb = tempGaussian.evaluate(tempTestPattern)
            conditionalProb.append(tempProb)
        ## find the largest conditional probability and assign
        ## this testing pattern to this class.
        maxProb = -1
        maxProbIndex = None 
        for j in range(0, len(conditionalProb)):
            tempCondProb = conditionalProb[j]
            if (tempCondProb >= maxProb):
                maxProb = tempCondProb
                maxProbIndex = j
        classAssignment = gaussians[maxProbIndex].getLabel()
        prediction.append(classAssignment)
    return prediction

def crossValidate(DataMatrix, fold, patternDimension, labelIndex):
    labels = DataMatrix[:,labelIndex]
    labels = np.unique(labels)
    ## manipulate the input data for cross validation
    errorRateList = []
    gaussianMatrix = []
    for cvtimes in range(0, fold):
        trainingSet, testingPatterns , testingLabels =  \
            getCrossValidationSet(fold, cvtimes, DataMatrix, patternDimension, labelIndex)
        ## group training data, return a dictionary whose 
        ## key is class label, and value is corresponding set of
        ## training data
        groupedTrainingSet = groupMessyData(trainingSet, patternDimension, labelIndex)
        ## construct gaussian objects
        gaussians = []
        for tempLabel in groupedTrainingSet:
            tempGaussian = gau.Gaussian(tempLabel, patternDimension)
            ## fitting the gaussian model
            tempGaussian.fitParameters(groupedTrainingSet.get(tempLabel))
            gaussians.append(tempGaussian)
        ## validate by tranversing the whole testing set
        prediction = getPrediction(testingPatterns, gaussians) 
        ## calculate the error rate of this time of validation
        assert len(prediction) == testingLabels.shape[0]
        numOfError = 0
        for i in range(0, len(prediction)):
            #print prediction[i], testingLabels[i]
            if prediction[i] != testingLabels[i]:
                numOfError = numOfError + 1
        errorRate = 1.0 * numOfError / testingLabels.shape[0]
        errorRateList.append(errorRate)
        gaussianMatrix.append(gaussians)
    return errorRateList, gaussianMatrix
