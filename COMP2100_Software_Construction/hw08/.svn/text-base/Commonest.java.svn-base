/** 
* @module Commonest.java
* @version 1.0 
* @since 2013-04-24
* @author Jimmy Lin (u5223173) - u5223173@uds.anu.edu.au
* 
* Edited by MacVim
* Class Info auto-generated by Snippet 
*/
// import list
import java.lang.Comparable;
import java.io.IOException;
import java.util.Hashtable;
import java.util.ArrayList;
import java.util.Scanner;

public class Commonest {
    // default THRESHOLD for judging the commonness of word
    public static int THRESHOLD = 5;

    public static void main (String [] args) throws IOException {
        // This loop is to parse the command line 
        // input for optional argument
        if (args.length > 1) {
            System.out.println("Too many parameters.");
            System.out.println("We just accept the first one..");
        }
        for (int i = 0; i < args.length; i ++) {
            // exception handling for weird value..
            try {
                Commonest.THRESHOLD = Integer.parseInt(args[i]);
            } catch (Exception e) {
                // weird input, parse next parameter
                continue;
            }
            // once one optional parameter detected,
            // directly leap out of the loop, only 
            // first parameter is accepted, first there
            // are multiple input.
            break;
            }
        // program will continue to behave under the default THRESHOLD 5.
        // if no integer value is captured.

        // initialisation for stream input
        Scanner input = new Scanner (System.in);
        String line = "";
        //  we set the prerecorded number of output pieces.
        CWTree.COUNTER = 0;

        // To further improve the efficiency, I decide to
        // construct a hashtable to mapping the string 
        // to number of times of its occurence
        //
        // Note that there is no mention in specification that
        // only Binary Search Tree can be used..
        Hashtable<String, Integer> tmpDict = new Hashtable<String, Integer> ();
        ArrayList<String> tmpArrayList = new ArrayList<String> ();
        System.out.println("Statistics of given redirected input: ");
        // now execute common word detection on given redirected input 
        for ( ; input.hasNext() ; ){
            line = input.nextLine();
            // replace those undesired character by whitespace
            line = line.replaceAll("[^a-zA-Z0-9]", " ");
            // remove redundant whitespace
            line = line.replaceAll(" [\t\n\b\f\r]", "" );
            // the following println is to see the outcome
            // after the string manipulation
            //System.out.println(line);
            String [] words = line.split(" ");
            for (int j = 0; j < words.length; j ++) {
                // convert to lower case for insertion and comparison
                String temp = new String (words[j].toLowerCase());
                // filter strings with only undesired character
                if (temp.matches("[ \t\n]") || temp.equals(" ") || temp.length() == 0) {
                    continue;
                }
                // insert into hash table, and arraylist.
                // scarifice space to have largest time complexity 
                if (tmpDict.containsKey(temp)) {
                    // update the existing item
                    Integer l = tmpDict.get(temp);
                    tmpDict.remove(temp);
                    // increment its frequency
                    l = l.intValue() + 1; 
                    tmpDict.put(temp, l);
                } else {
                    // initialise one new item.
                    tmpArrayList.add(temp);
                    tmpDict.put(temp, new Integer (1));
                    //tmpTree.insert(words[j].toLowerCase());
                }
            }
        }

        // add data from hashtable and arraylist to binary search tree
        // here we just use binary search tree for sorting
        CWTree<Token> tmpTree = null;
        // tranverse through all keys of dictionary
        for (int k = 0; k < tmpArrayList.size(); k ++ ) {
            String insertedWord = tmpArrayList.get(k);
            int freq = tmpDict.get(insertedWord);
            // insert first word to binary search tree.
            if (tmpTree == null) {
                tmpTree = new CWTree<Token> (new Token(insertedWord, freq));
            } else {
                tmpTree.insert(new Token (insertedWord, freq));
            }
        }
        // print result to the console
        tmpTree.printResult();
    }
}

// set up a new interface to solve the problem of conflict
// that is, new node to be inserted into one tree has already exists.
interface Conflict<K> {
    void update(K k);
}

// class for tree structure
class CWTree<T extends Comparable<T> & Conflict<T>> implements Comparable<CWTree<T>>, BST<T> {
    // set counter to record how many words have
    // been put into the console for display
    static int COUNTER = 0;

    // overloaded constructors
    public CWTree () {}
    public CWTree (T t) {
        this.value = t;
    } 

    // fields
    private T value;
    // tree structure
    private CWTree<T> left ;
    private CWTree<T> right ;

    // provide interface to private field
    // for information and manipulation security 
    public T getValue() { return this.value; }
    public CWTree<T> getRight() { return this.right; }
    public CWTree<T> getLeft() { return this.left; }

    // insert a new value of generic type T into this tree
    public void insert(T t) {
        // construct one temporary tree node so as to 
        // do comparison by using defined compareTo()
        if (this.value.compareTo(t) > 0 ) {
            // insert to left side
            if (this.left == null) {
                this.left = new CWTree<T> (t);
            } else {
                this.left.insert(t);
            }
        } else if (this.value.compareTo(t) == 0) {
            // no insertion, but increase the frequency
            this.value.update(t);
        } else {
            // insert to right side
            if (this.right == null) {
                this.right = new CWTree<T> (t);
            } else {
                this.right.insert(t);
            }
        }
    }

    // compareTo method for the Comparable interface
    public int compareTo(CWTree<T> other) {
        return this.value.compareTo(other.getValue());
    }

    // method to execute the printing task in a recursive way.
    public void printResult() {
        // 
        if (Commonest.THRESHOLD <= CWTree.COUNTER - 1) return ;
        else {
            if (this.right != null) this.right.printResult();
            if (Commonest.THRESHOLD > CWTree.COUNTER ) {
                System.out.println(this.value.toString());
                // here we restrict the pieces of output.
                // increment the number of pieces being ouput.
                CWTree.COUNTER++;
            }
            if (this.left != null) this.left.printResult();
        }
    }

}

/** Here we construct one new class to restore
 * the information of collected words in given text.
 * */
class Token implements Comparable<Token>, Conflict<Token> {
    // identifier of one word
    private String word;
    // times of occurrence
    private int frequency;

    // Constructors
    public Token (String w) {
        this.word = w;
        this.frequency = 1;
    }
    public Token (String w, int fre) {
        this.word = w;
        this.frequency = fre;
    }
    // supply the public interface for private field
    public String getWord() { return this.word; }
    public int getFrequency() { return this.frequency; }

    // operation for the same word, only increment 
    // the frequency.
    public void update(Token other) {
        this.frequency += other.getFrequency();
    }
    // method defined for comparable interface, in this
    // way we can directly determine the order for 
    // screen printing.
    public int compareTo (Token other) {
        if (this.frequency != other.getFrequency()) {
            // compare by frequency
            return this.frequency - other.getFrequency();
        } else {
            // compare by alphabetical order
            return (-1)*this.word.compareTo(other.getWord());
        }
    }

    // Return the information of one token.
    //  including times of occurence and the value.
    // Also note the mechanism to restrict the number 
    // of pieces for output.
    public String toString () {
        String str;
        // string format as required by specification
        str = String.format("%5d %s", this.frequency, this.word);
        return str;
    }
}
