Name: Andrew RubinettEID: ar37846CS Login: ar37846Email: arubinett@gmail.comLecture 34 1. Because if a channel can only transmit C bits, and each signal is made up of h bits, it is impossible to send more than C/h signals because that would be more bits than the channel is able to transmit.2. The more attempts are made to send a message through a noisy channel, the more likely it is that the message gets to its destination.Lecture 351. log(10) = approx. 3.3222. There are a lot of different factors that affect the likelihood of each character to make it virtually impossible to know the true entropy.3. Zero-order takes into account the likelihood of length 0 segments, so it doesn’t take them into account at all. First-order takes into account the likelihood of length 1 segments, second-order length 2 segments, third order length 3 segments, and so on.Lecture 361. Sometimes the probability can defend on other factors that may not be known to everybody involved in the sending of the message.2. A person only needs enough information to remove all doubt of the content of the message. If people have different amounts of knowledge about what the message could be, it can change the amount of knowledge needed to know the true content of the message.3. Redundancy only exists if the entropy of a language is less than the encoding used for that language, because otherwise, only as much information as necessary is sent.Lecture 371. It seems like a paragraph, it’s not a simple transformation because it doesn’t use letters, it is probably easy to figure out the double letters first (i.e. ++, 88, etc.), each symbol likely has a 1 to 1 relationship with a letter. These all make it easier to decode the message because they put the message into a language that’s easier to understand2. If a certain encryption algorithm always has the same key, then it isn’t necessary to know the key for a specific instance of the algorithm to be able to decode the message.3. It should preserve the content of the message.4. Redundancy between the plaintext and the ciphertext could be the same, which could make it easier for someone to decipher the message without the key.Lecture 381. P2. E(P, Ke)3. Because sometimes the patterns can give hints about what type of information the message contains.4. If a message is determined to be of a certain language, the properties of the language can also be applied to the encrypted message to help decipher it.Lecture 391. The time required to break an encryption algorithm may be exponentially large, which makes it an unfeasible solution.2. Because, assuming a linear search is used, the correct solution will be found on average about halfway through the list, which would be 2^n-1 operations.3. To accomplish both confusion and diffusion, each mechanism is necessary.4. Confusion is changing how the message looks, whereas diffusion is changing the distribution of the information throughout the message.5. They are both important, and they work together to make encryption algorithms that are difficult to decipher.Lecture 401. A monoalphabetic substitution always substitutes the same thing for each letter, while a polyalphabetic substitution changes what letter is substituted depending on some other factor.2. A mapping of the plaintext letter corresponding to its substitution in the ciphertext.3. Because there are k! possible mappings between letters in an alphabet of k letters.4. The amount of letters that the message is shifted.5. The keyspace is the number of letters in the alphabet.6. No, it can be solved in k attempts, where k is the number of letters in the alphabet.7. Look at the column corresponding to the key letter and find the row where the letter in the table matches the ciphertext letter. The corresponding row shows the letter for the plaintext.Lecture 411. Because each letter in the ciphertext can correspond to 26 different letters and there are 3 letters in the ciphertext, there are 26^3 possible keys.2. Because it is known that simple substitution is used, both y’s are substituted by the same letter, which reduces the amount of possible keys to n! where n is the number of different letters in the ciphertext.3. Yes, if enough different languages are used it seems like the correspondence between the ciphertext language and the plaintext language can be removed. Also, the fact the encryption algorithms are made public leads me to believe that wouldn’t be the case if information could be acquired from knowing the encryption algorithm.Lecture 421. There is nothing about the key that offers any insight into what the contents of the message could be, so the possible keyspace cannot be reduced by cryptoanalysis.2. If the key wasn’t random, somebody who knew the algorithm that produced the key could figure out the key and the message could be decoded.3. A key needs to be sent without threat of interception for an encryption scheme to be strong. If a key needs to be as long as the message it is encrypting, and there exists a channel by which the key can be sent covertly, that channel should just be used to send the message. If there doesn’t exist a channel by which the key can be sent covertly, the algorithm is not strong.Lecture 431. It retains the frequencies of each letter, which can be used to make the original message easier to decode.Lecture 441. Symmetric2. Key distribution involves the issue of making sure each person in the system has access to the right key at the right time, whereas key management involves the issue of the system using the right keys for the right encryption and decryption operations.3. No, Ks is open for anyone to use to encrypt a message. Only S can decrypt messages that are encrypted using Ks because those messages are decoded by the key Ks-1, which only S has access to.4. If there is a secure way to distribute keys, then symmetric systems are easy to manipulate, but there has to be a lot of keys. Asymmetric key systems are good when there is no secure way to distribute keys, and it also requires less keys. However, each public key is a lot more work to generate.Lecture 451. Block cyphers are more secure in the sense that it is very difficult for an encrypted message to be altered without the receiver realizing.2. If an encryption algorithm is non-malleable, wrong information will not be sent because part of a message cannot be changed without affecting the rest of the message.3. Homomorphic encryption allows encrypted data to be modified without exposing the data.Lecture 461. subBytes, a simple substitution is performed.2. shiftRows, the bytes are moved around in a specified way.3. The multiplication in the mixColumns step uses numbers that make it more difficult to optimize the step.4. The blocks allow for non-malleable encryption, and more rounds create a more secure encryption5. The more rounds are used, the more the original message is changed, and the harder it becomes to decode without the proper key.Lecture 471. Identical plaintext blocks results in identical ciphertext blocks.2. By “randomizing” a block before it is encrypted.3. An attacker can observe the process and identify the first block that changed to derive information about the plaintext blocks.4. It is not encrypting information to later to decrypted and recovered. Instead, it is encrypting information to serve as a sequence of random bits to use in some other context, such as for a one-time pad.Lecture 481. The private key.2. Because in order to have an encryption that is not invertible, there must be some function that is not invertible.3. It makes it irrelevant who has access to the key, because only the person for whom the message is intended is able to decrypt that message using the private key.4. {P}K-15. Asymmetric algorithms are much less efficient that symmetric algorithms, by as many as 10,000 times.Lecture 491. Yes, either key can be used for encryption or decryption and the corresponding key will either decrypt it or encrypt it accordingly.2. RSA utilizes the factoring of large numbers, which is very difficult to invert due to prime numbers.3. No4. Because that person wouldn’t have A’s private key to be able to decrypt the message.5. Because anybody has access to A’s public key.6. Only B can send a message that can be decrypted with B’s public key because B is the only one that has the private key to encrypt that message.7. Anybody has access to B’s public key and is able to decrypt that message.8. The message with confidential information should be encrypted with a public key, and a message with a basic, unimportant message should be encrypted with a private key.Lecture 501. Hash functions need to be applied many times to arbitrary pieces of data, so it needs to be easy to compute to make the function efficient.2. Weak collision resistance means that it is hard to find a value that hashes to a value that some other value has already hashed to, and strong collision resistance means that it is hard to find two values that hash to the same value.3. Preimage resistance means its hard to find a value that hashes to a specified value, while second preimage resistance means that it is hard to find a value that hashes to a value that some other value has already hashed to.4. We can expect a collision after evaluating the function for 1.25 * 2^64 values5. We can expect a collision after evaluating the function for 1.25 * 2^806. Hash functions are good at encrypting data, but are not good at decrypting data.7. It is unlikely that two different messages will have the same hash.8. B can send a confidential message using A’s public key and also send a confidential message containing the value that the hash function returned for that message. A can send the message it receives from B through the hash function to see if it returns the same value, which would show the message was the same.Lecture 511. No, S doesn’t have access to R’s private key to be able to send that message.2. Yes, both keys are needed to be able to access the message regardless of what order the keys are used to perform the encryption.3. No4. The message needs to be authentic and confidential to make sure the key is for the right person, but cannot be accessed by everyone.Lecture 521. The eavesdropper wouldn’t be able to find out anything.2. The eavesdropper would be able to find out the shared secret if they overheard the message containing the value of g^b mod p.3. The eavesdropper would be able to find out the shared secret if they overheard the message containing the value of g^a mod p.