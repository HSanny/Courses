Name: Andrew RubinettEID: ar37846CS Login: ar37846Email: arubinett@gmail.comLecture 531. If a signature is reusable, it leaves open the possibility that it could accompany a message it wasn’t intended for, thereby legitimizing an illegitimate message.2. The message may be very long and using a public key is expensive, so that hash function provides a reliable shortened version of the message.3. R is assured that S did send a message, and S was the only possible entity that could have sent the message.Lecture 541. It is necessary to have someone with whom to start the “web of trust” to actually make sure people’s keys are accurate.2. Because the third party then knows that X validates the pairing of a subject and their private key. No one else besides X can sign a message with X’s private key.3. It’s necessary to verify that the values that were hashed by X are the same values that were sent in the certificate.4. Z would not be able to trust that X actually sent the certificate.Lecture 551. A public key is given that is assured to be correctly linked to the subject, which can then verify other users.2. Verification may need to be temporary.3. The message the issuer verified is not the same as the one the one the user receives.Lecture 561. BLP, Great Wall, RBSC.2. The message may not be able to be sent, or be sent securely.3. If keys don’t commute, there will always be the problem that a subject must open something it doesn’t have a key to.4. Messages 1 and 2 are XOR together, the result of which is XOR with message 3.5. Messages 2 and 3 are XOR together.6. Messages 1 and 2 are XOR together.7. There are a lot of potential vulnerabilities.Lecture 571. Protocols ensure that information can be transferred.2. Cryptographic protocols ensure that information can be transferred securely at any time.3. There is a public key system that works, and each party has a correct public key for the other.4. The key is known by both parties, and each party knows it’s talking to the correct party.5. No, one party doesn’t always know it’s talking to the correct other party.6. An attacker can gain access by applying its own key on a message and otherwise performing as the protocol suggests.Lecture 581. Any extra information could lead to security vulnerabilities or a greater chance of error.2. Any encryption makes a protocol more complicated, which could lead to something going wrong.Lecture 591. There are many ways a cryptographic protocol can be compromised.2. If an attacker gains access to one message in a protocol, they could use that to mess up future uses of that protocol.3. Yes, an attacker could corrupt a message that is being sent without actually knowing what the message contained is.4. An attacker can only use information that it has access to.5. A party won’t have any access to any information it doesn’t send or receive in a message.Lecture 601. No, it would be impossible to know if the key was fresh.2. Step 1: A wants to set up key with B, S believes A wants to set up key with BStep 2: S has created key between A and B, A knows key was created that is freshStep 3: A wants to tell B that it has key to communicate, B knows S created key between it and AStep 4: B wants to tell A that it can use key, A knows B has key and can use itStep 5: A wants to tell B that it can use key, B knows A can use keyLecture 611. The attacker could use previous keys between A and some other party that it created prior to A changing its private key with S.2. It depends on the strength of the encryption.3. I would not worry about if Kas gets compromised because that will always lead to problems, and I would add some sort of nonce between A and B that is created by A.Lecture 621. S creates a valid key between A and B that B sends to A.2. N-S guarantees that A and B each know that the other has the key and the key works while O-S doesn’t.3. Have some trusted third party that acts as an intermediary between A and B.Lecture 631. In order for a protocol to be used safely, it needs to be verified to some extent.2. It is logic that identifies what each principal can infer based on messages they have either sent or seen.3. Beliefs represent that state of data at various points in the program.Lecture 641. A system of logic that determines the truth of some piece of logic.2. If A has a key that it shares only with B, and it receives a message that can be decoded with that key, then it is reasonable to assume that message was sent by B.3. If A receives something that it believes is fresh and also from B, then it is reasonable to assume that A believes B knows the value it sent.4. If A believes it can trust B on matters of type X, and A believes that B is confident in X, then A should trust B’s judgment on X.5. Idealization is turning steps in a protocol into the corresponding statements in BAN. It is necessary to utilize the logic to find potential vulnerabilities.Lecture 651. There can’t be any vulnerability when no information is protected.2. Some principals receive information at different steps in a protocol.3. It writes out step by step what each principal assumes after each step, which can reveal assumptions that aren’t intended.