Name: David Barron
EID: db25633
csID: davidbar
email: d.barron91@utexas.edu
CS 361 Young
HW4

L53
1.	We don’t want the signature to be attached to another document.
2.	Public key is expensive to apply, and a hash is a fixed number of bits as opposed to an arbitrarily large file.
3.	Message is unforgeable, authentic, S sent it, tamperproof, and non-reusable.
L54
1.	You have an external trusted check on reliability.
2.	 So someone viewing the certificate can know it did indeed come from X as X is the only one with the private key.
3.	The hash provides a point of comparison for the other contents of the certificate to verify that the items have not been altered or corrupted in some way.
4.	It would not be able to verify the certificate.
L55
1.	The root should be that of an impeachable authority.
2.	To provide a valid time window and allow the certificate to expire.
3.	That they have been altered.
L56
1.	Encryption/Decryption and Public/Private Key
2.	Someone can extract the message or one of the two parties cannot successfully exchange the message securely.
3.	Encryption algorithms typically do not commute, which they must do in order for our secure system to behave the way a strongbox with two locks does.
4.	An eavesdropper intercepts all 3 stages of the message and XORs them.
5.	XOR second and thirds stages.
6.	XOR first and second stages.
7.	Because nuances can be very subtle. 
L57
1.	Well, it just is.
2.	There are a lot of bad people on the internet, so it is important to be as safe as possible and protect our data.
3.	Public Key infrastructure, other has reliable public key.
4.	That the key gets across securely.
5.	Maybe.
6.	Explained in class.
L58
1.	Because it is a distributed environment and each subject must know what it must do next after receiving a message. 
2.	Maybe the encryption is expensive. Why do something expensive if it’s not needed.
L59
1.	It can be difficult to determine if the “attack” was actually just an overlooked error by the engineers. 
2.	Subjects may be granted access to processes that they should not have access to.
3.	Known-key, replay, and Interleaving Attack. These typically just disrupt flow of information.
4.	Messages cannot be arbitrary, but hard to say beyond that.
5.	More subjects know less things, important in large networks.
L60
1.	Yes, but some guarantees of freshness are lost.
2.	A sends to S identity of A, B, and nonce Na; S sends to A nonce Na, identity of B, key for AB communication, package for B secured with BS key; A sends to B package from S; B sends to A nonce Nb using key AB generated by S; finally A sends to B Nb-1 to verify.
L61
1.	It couldn’t?
2.	Sure, it’s perfectly fair to consider. It is important to design protocols with disaster mitigation in mind.
3.	Add a nonce.
L62
1.	It is much harder for someone to intercept t a message and use it later in a playback attack. 
2.	In Otway-Rees, one subject does not know that the other received the final key to be used for communication.
3.	I don’t know. Maybe add a way to determine the message did come from A.
L63
1.	It makes it easier to spot flaws in protocol, especially since they are already difficult to get correct.
2.	Allows reasoning about what principals inside protocol should be able to infer about messages they see; allows for abstract proofs.
3.	Beliefs may delimit the structure of a message, say knowing how the data inside is laid out?
L64
1.	Formal logic that extends predicate logic.
2.	The keys used to send a message check out, so it’s safe to believe a subject said something.
3.	If the nonces check out, then it is safe to believe that a subject also believes something.
4.	If a subject has jurisdiction of something, and one believes that subject, then it is safe to believe that something too.
5.	Idealization helps clear out parts of a message that do not contribute to the beliefs of the recipient.
L65
1.	It’s easy to manipulate.
2.	Because the protocol is systematic.
3.	Exposing assumptions provides some insights into possible security exploits since they are not necessarily proved through BAN logic.
