Andrew Nguyen
an9395
anguyen1
anguyen11@utexas.edu


Lecture 66
1) PGP stands for Pretty Good Privacy. It is a program that provides
   encryption and decryption tools for non cryptography experts to use.

2) Zimmermann wanted to provide strong email encryption to everyone. He had
   a strong distrust of the government and wanted to provide some security
   against having your information read.

3) Yes. There have ben several instances where authorities have proven
   unsuccessful in breaking PGP-encrypted files.

4) People might opt for the commercial version of PGP over the free version
   because they want the support that comes with paying.

Lecture 67
1) PGP provides authentication by generating a hash of the message and
   signing it with the sender's private key. The receiver then knows that
   the hash came from that sender and can check that the message was
   unaltered using the hash.

2) PGP provides confidentiality by generating a random session key for a 
   message. The message is encrypted using that key, and the key itself is
   encrypted using the receiver's public key. Thus, only the receiver can
   decrypt the key and then use it to decrypt the message.

3) To get both confidentiality and authentication, apply the authentication
   step to the original message before applying the confidentiality message
   to the resulting message.

Lecture 68
1) Besides authentication and confidentiality, PGP also provides compression,
   email compatibility, and segmentation.

2) Compression is needed to save bandwidth when sending a message.

3) Compression is done after signing the message so that the signature does
   not depend on the compression algorithm.

4) Radix-64 conversion is used to eliminate certain bit strings that might
   be interpreted as control commands by some email systems. It works by 
   taking 3 octets and converting them into four ASCII characters.

5) Segmentation is needed because some email systems restrict message 
   lengths. So PGP automatically breaks large messages into segments that
   all email systems can handle. 

Lecture 69
1) The four kinds of keys used by PGP are session keys, public keys, private
   keys, and passphrase-based keys.

2) Session keys need to be randomly generated and only used once. 

3) Session keys are generated by taking a previous session key keystroke
   movements/timing, mouse movements, etc. and using them to form a new
   key.

4) To generate RSA keys, you need two large primes. So an odd number of
   sufficient size is randomly generated and checked for primality. This is
   repeated until two primes are found.

5) Private keys are protected with user-supplied passphrase-based keys. They
   need to be protected because if the private keys are compromised then the
   whole system is compromised.

Lecture 70
1) Users differentiate various public/private key pairs by generating key
   IDs that are likely to be unique for a given user. Those key IDs are then
   sent along with a message to to signify which key pairing to use.

2) Private key rings contain private keys, their associated public keys, 
   their key IDs, a timestamp, and user IDs.

3) Public key rings contain public keys of other users, their key IDs, user
   IDs, and timestamps.

4) To retrieve a private key, the receiver gets the encrypted private key
   from the private key ring. The user is then provides the pasphrase to 
   decrypt the private key.

5) The key legitimacy field is used to indicate how much PGP trusts that a
   public key actually belongs to a user. 

6) Keys are revoked through a signed key revocation certificate from the
   key's owner. 

Lecture 71
1) The consumer problem is where the attacker comes between the client and
   the service and disrupts the communication. The producer problem is where
   the attacker produces so many requests that the server for the service is
   overwhelmed. Producer problems are more prevalent.

2) Syn flooding is when an attacker sends SYN packets with forged return 
   addresses. The server then fills up its table with half-open connections.
   Until those half-open connections time out, legitmate accesses are denied
   because there is no room in the server's table.

3) Increasing the server's table is expensive, and the attacker could simply 
   send more requests to clog it up. Shortening the time-out period might
   disallow connections by slower clients. Filtering suspicious packets is
   difficult to do.

Lecture 72
1) Packet filtering prevents attacks by determining which packets are bad and
   throwing them away. However, it is often very difficult to determine which
   packets should be thrown away. 

2) Intrusion detection analyzes traffic patterns and to anomalous patterns.
   It works after an attack has begun. Intrusion prevention attempts to
   prevent intrusions by blocking the attacks before they begin.   

3) Over-provisioning the network is where there are so many servers that
   it is impossible for them to be overwhelmed. Filtering attack packets
   involves distinguishing attack packets from regular packets and
   discarding them. Slowing down the processing works by disadvantaging
   attackers who are trying to flood a system more than legitimate users.
   The "speak-up" solution is where the server requests additional info
   from everyone sending you packets. Attackers are probably maxed out
   and cannot send any more information. 

Lecture 73
1) A false positive is when legitimate behaviour is classified as an attack.
   A false negative is when a genuine attack is not detected. Which is worse
   depends on the situation and how ready the system is to handle an attack.

2) An IDS is accurate if it detects all genuine attacks. An IDS is precise
   if it never reports legitimate behavior as an attack. 

3) You can either design the IDS to be very aggesive or restrictive in
   identifing attacks.  

4) Base-rate fallacy is where there is a heavy focus on malicious packets
   even though they are statistically rare. An IDS that identifies bad
   packets at a higher rate than they appear is a bad thing. 

Lecture 74
1) Code Red version 1 spread itself by generating a random list of IP 
   addresses and attempting to infect those computers. Then it would
   launch a DoS flooding attack on www.whitehouse.gov.

2) It was ineffective because it used the same seed everytime to generate
   the list of IP addresses. So every infected machine attacked the same
   machines. 

3) Memory resident means that the worm was stored in volatile memory. A 
   simple reboot would get rid of the worm. 

4) Code Red version 2 used a randomly generated seed to generate the list
   of IP addresses, and many more computers were affected. 

Lecture 75
1) Code Red II is related to the original Code Red because it contained the
   string "CodeRedII."

2) It incorporated its elaborate propogation scheme because it is more
   likely that machines in the same network are running the same software.

3) Code Red II installed a backdoor for root-level access. Now the infected
   computer could be used as zombies for future attacks.

4) Even if there are patches out to fix vulnerabilities, a large population
   of unpatched machines allows for the continued circulation of worms.

5) That people don't patch their machines and leave them vulnerable to attack.

Lecture 76
1) It is necessary because most consumers are not security experts. There 
   needs to some uniform standard to let consumers know about security.

2) A set of requirements defining security functionality, a set of assurance
   requirements needed for establishing the functional requirements, a
   methodology for determining that the functional requirements are met, and
   a measure of the evaluation result indicating the trustworthiness of the
   evaluate system.

3) Crypto devices have a separate evaluation mechanism, because it is a 
   sensitive area. Thus the government takes care of that evaluation. 

4) Level 1 is just basic security with at least one approved algorithm or
   function. Level 2 includes improved physical security and tamper-evident
   packing. Level 3 has strong tamper-resistance and countermeasures. Level
   4 has a complete envelope of protection including immediate zeroing of
   keys upon tampering.

Lecture 77
1) The Common Criteria is a set of documents and a methodology for applying
   those documents to evaluate secure systems.

2) It is shared (with slight modifications) among 26 different countries. 

3) Countries don't trust each other.

4) A protection profile is a description of a family of products in terms of
   threats, environmental issues and assumptions, security objectives, and
   the Common Criteria. A security target is a document that contains the
   security requirements of a product to be evaluated. It specifies the
   measures offered by the product to meet those requirements, and may match
   a protection profile. 

Lecture 78
1) To ensure the security of the records in a waste management system.

2) They provide a systematic way of identifing all relevant parts to be looked
   at to determine whether or not a system is secure. 

3) It represents a mapping of threats/assumptions to security objectives/
   requirements. It provides a systematic way of deciding whether threats and
   assumptions are being addressed by mechanisms and requirements. 

Lecture 79
1) The goal is to determine if the Sun Identity Manager is sufficiently secure.

2) Protection profile evaluation is the evaluation of a standard set of threats
   to a particular class of system. It states that if certain criteria are met,
   then the system will be secure. Security target evaluation is the specific
   implementation of those criteria. How the particular system satisfies the
   necessary prerequisites needs to be explained. 

Lecture 80
1) EAL stands for evaluation assurance level. It shows how much evidence has
   been put forward to demonstrate the security of the system.

2) Either the government or a certifying agency. 

3) Countries don't trust each other.

4) No. Because vendors might lie about their product, there needs to be an
   independent entity to perform the evaluation. 

5) You shouldn't decide on what constitutes a pass after you test the code.
   There should be an established standard that the code must then try to
   meet.






