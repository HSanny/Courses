/*##############################################################
## MODULE: Bidding.java
## VERSION: 1.0 
## SINCE: 2014-01-14
## AUTHOR: 
##         JIMMY LIN (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##    Algorithm Assignment #2: BIDDING SYSTEM
##    We incrementally implement the bidding-item stable matching.
## 
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;

// ****************************************************************
// Item data structure
class Item implements Comparable<Item>{
    // fields characterizing item
    int id;  
    int quality;  
    int price;  // unit: cents

    int highest_bid_id;  
    int highest_bid_price;  

    static int id_count;  // as id assigner

    // constructor for item class
    Item (int quality, int price) {
        this.id = id_count ++;
        this.quality = quality;
        this.price = price;  
        this.highest_bid_price = price;
        this.highest_bid_id = -1;
        this.matchedBySingleItem = false;
    }
    public String toString () {
        String str = "bid: " + this.quality + "," + this.price;
        return str;
    }
    public int compareTo (Item item) {
        return item.quality - this.quality;  // descending order
    }
}

// ****************************************************************
// Bid data structure
class Bid {
    int type;
    int bid_id;

    static int id_count;
    Bid (int type) {
        this.type = type;
        this.bid_id = Bid.id_count++;
    }
    int compareTo (Bid b) {
        if (b.type == 1 && this.type == 1) {
            return b.offer - this.offer;
        } else if (b.type == 2 && this.type ==2) {
            return b.slope - this.slope;
        } else {
            return b.type - this.type;
        }
    }
}

class SingleItemBid extends Bid {
    int item_id;
    int offer;

    SingleItemBid (int offer, int item_id) {
        super(1);
        this.offer = offer;
        this.item_id = item_id;
    }
    int getWeight () {
        // System.out.println(this.offer);
        return this.offer;
    }
}
class LinearBid extends Bid implements Comparable<LinearBid> {
    int intercept;
    int slope;
    LinearBid (int intercept, int slope) {
        super(2);
        this.intercept = intercept;
        this.slope = slope;
    }
    int getWeight (int quality) {
        int weight = quality * this.slope + this.intercept;
        // System.out.println(weight);
        return weight;
    }
}
// ****************************************************************

class Bidding {
    public static void main (String [] args) throws IOException {
        BufferedReader reader = new BufferedReader(new
                InputStreamReader (System.in));

        // parse the number of items
        int nItems = Integer.parseInt(reader.readLine());
        // System.out.println("number of items: " + n);

        // create and parse item array 
        // use priority queue to sort the items
        PriorityQueue<Item> pqItems = new PriorityQueue<Item> (nItems);
        String line = null;
        for (int i = 0; i < nItems; i ++) {
            line = reader.readLine();
            String [] item_infos = line.split(" ");
            int tmp_quality = Integer.parseInt(item_infos[0]);
            int tmp_price = Integer.parseInt(item_infos[1]);
            pqItems.offer(new Item (tmp_quality, tmp_price));
            // System.out.println(items[i].toString());
        }
        Item [] items = new Item [nItems];
        // the sorting priority queue
        for (int i = 0; i < nItems; i ++) {
            items[i] = pqItems.poll();
            // System.out.println(items[i].quality);
        }

        // create and parse bidding arraylist
        ArrayList<Bid> bids = new ArrayList<Bid> ();
        ArrayList<Bid> matchedBids = new ArrayList<Bid> ();
        while ((line = reader.readLine()) != null) {
            String [] bidding_infos = line.split(" ");
            int type = Integer.parseInt(bidding_infos[0]);
            if (type == 1) { // single-item bid
                int tmp_price = Integer.parseInt(bidding_infos[1]);
                int tmp_id = Integer.parseInt(bidding_infos[2]);
                SingleItemBid newSingleBid = new SingleItemBid(tmp_price, tmp_id);
                bids.add (newSingleBid);
                // update the item
                for (int i = 0; i < nItems; i ++) {
                    if (items[i].id == tmp_id && items[i].highest_bid_price < tmp_price) {
                        // remove the original one which worths less
                        for (int k = 0; k < nItems; k ++) {
                            if (!items[k].matchedByLinearBid && !items[k].matchedBySingleBid)
                                local_weight += items[k].price;
                        }
                        if (items[i].) {
                            
                        }
                        // accept since this bid provide higher price
                        items[i].highest_bid_price = tmp_price;
                        items[i].highest_bid_id = Bid.id_count - 1;
                        // add the new single bid
                        matchedBids.add(newSingleBid);
                    }
                }
                // System.out.println("1 " + tmp_id + ", " + tmp_price);
            } else if (type == 2) { // linear bid
                int intercept = Integer.parseInt(bidding_infos[1]);
                int slope = Integer.parseInt(bidding_infos[2]);
                LinearBid newLinearBid = new LinearBid(intercept, slope);
                bids.add (newLinearBid);
                int maximum_weight = -Integer.MAX_VALUE;
                int nMatchedBids = matchedBids.size();

                for (int i = 0; i < nMatchedBids + 1; i++) {
                    // reset the assignment 

                    // create temporary contribution set
                    PriorityQueue<Bid> tmp_Bids = new PriorityQueue<Bid>
                        (nMatchedBids); 
                    for (int j = 0; j < nMatchedBids; j ++) {
                        if (i == j) continue;
                        tmp_Bids.offer(matchedBids.get(j));
                    }
                    if (i != nMatchedBids) {
                        tmp_Bids.offer(newLinearBid);
                    }
                    // compute the local weight
                    local_weight = 0;
                    // to array
                    Bid [] tmp_Bids_array = new Bid [nMatchedBids];
                    for (int j = 0; j < nMatchedBids; j ++) {
                        tmp_Bids_array[j] = tmp_Bids.poll();
                        if (tmp_Bids_array[j].type == 1) {
                            // update to be single item bid
                            local_weight += tmp_Bids_array[j].offer;
                            for (int k = 0; k < nItems; k ++) {
                                if (items[k].id == tmp_Bids_array[j].item_id) {
                                    items[k].matchedBySingleBid = true;
                                    break;
                                }
                            }
                        } else {
                            int tmp_slope = tmp_Bids_array[j].slope;
                            int tmp_intercept = tmp_Bids_array[j].intercept;
                            // update to be linear bid 
                            for (int k = 0; k < nItems; k ++) {
                                if (!items[k].matchedByLinearBid && !items[k].matchedBySingleBid) {
                                    local_weight += tmp_slope * items[k].quality + tmp_intercept;
                                    items[k].matchedByLinearBid = true;
                                    break;
                                }
                            }
                        }
                        for (int k = 0; k < nItems; k ++) {
                            if (!items[k].matchedByLinearBid && !items[k].matchedBySingleBid)
                                local_weight += items[k].price;
                        }
                        if (local_weight > maximum_weight) {
                            maximum_weight = local_weight;
                        }
                    }

                }
                 // System.out.println("2 " + intercept + ", " + slope);
            } else if (type == 3) { // for summary
                int maximum_weight = 0;
                int nBids = bids.size();
                int [] assignment = new int [nItems];
                // assignment
                for (int i = 0; i < nItems; i ++) {
                    assignment[i] = items[i].highest_bid_id;  // retained by seller  
                    maximum_weight += items[i].highest_bid_price;
                }
                // output
                String summary = Integer.toString (maximum_weight);
                for (int i = 0; i < nItems; i ++) {
                    summary += " " + Integer.toString (assignment[i]);
                }
                System.out.println(summary);
            } 
        }
    }
}
