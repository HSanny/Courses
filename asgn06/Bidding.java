/*#############################################################
## MODULE: Bidding.java
## VERSION: 1.0 
## SINCE: 2014-04-16
## AUTHOR: 
##         JIMMY LIN (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##    Algorithm Assignment #6: A faster algorithm of dealing with
## stability violation.
## 
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.Collections;
import java.util.HashSet;

// ****************************************************************
// Item data structure
class Item implements Comparable<Item> {
    // fields characterizing item
    int id;  
    int quality;  
    int reservePrice;  // unit: cents

    int startPrice;
    int toBid;

    static int id_count;  // as id assigner

    // constructor for item class
    Item (int quality, int reservePrice, int startPrice) { this.id = id_count ++;
        this.quality = quality;
        this.reservePrice = reservePrice;  
        this.startPrice = startPrice;
    }
    public String toString () {
        String str = "Item: " + this.quality + "," + this.reservePrice;
        return str;
    }
    public int compareTo (Item item) {
        return -(item.quality - this.quality);  // descending order
    }
}

// ****************************************************************
// Bid data structure
class Bid {
    int type;
    int id;

    static int id_count;

    Bid (int type) {
        this.type = type;
        this.id = Bid.id_count++;
    }
}

class SingleItemBid extends Bid implements Comparable<SingleItemBid> {
    Item toItem;
    int offer;

    SingleItemBid (int offer, Item toItem) {
        super(1);
        this.offer = offer;
        this.toItem = toItem;
    }
    int getWeight () {
        if (this.offer > this.toItem.reservePrice) {
            return this.offer;
        } else {
            return this.toItem.reservePrice;
        }
    }

    // compare single-item bid based on the item it offers to
    public int compareTo (SingleItemBid sib) {
        int qualityDiff = sib.toItem.quality - this.toItem.quality;
        if (qualityDiff != 0)
            return qualityDiff;
        else {
            return this.toItem.id - sib.toItem.id;
        }
    }
}
class LinearBid extends Bid implements Comparable<LinearBid> {
    int slope;
    int intercept;
    int toItemIndex;

    LinearBid (int intercept, int slope) {
        super(2);
        this.intercept = intercept;
        this.slope = slope;
        this.toItemIndex = -1;
    }
    int getWeight (Item item) {
        int weight = item.quality * this.slope + this.intercept;
        return weight;
    }
    public int compareTo (LinearBid lb) {
        return lb.slope - this.slope;
    }
}

// ****************************************************************
class Bidding {
    /* for debugging */
    public static void print (int violation, int amountToIncrement, int itemIdx) {
        /*
           System.out.println("Vio: " + violation + ", Item_idx: " + itemIdx + 
           ", amount: " + amountToIncrement);
           */
    }

    public static void main (String [] args) throws IOException {
        BufferedReader reader = new BufferedReader(new
                InputStreamReader (System.in));
        /* Parse the number of items */
        int nItems = Integer.parseInt(reader.readLine());
        if (nItems <= 0) return ; assert (nItems > 0);
        // System.out.println("number of items: " + n);

        /* Use hash map to restore items */
        HashMap<Integer,Item> hashItems = new HashMap<Integer,Item> (nItems);
        ArrayList<Item> arrayItems = new ArrayList<Item> ();

        String line = null;
        for (int i = 0; i < nItems; i ++) {
            line = reader.readLine();
            String [] item_infos = line.split(" ");
            int tmp_quality = Integer.parseInt(item_infos[0]);
            int tmp_reservePrice = Integer.parseInt(item_infos[1]);
            int tmp_startPrice = Integer.parseInt(item_infos[2]);
            assert (tmp_startPrice <= tmp_reservePrice): 
                "startPrice is greater than reservePrice.";
                    Item newitem = new Item (tmp_quality,
                            tmp_reservePrice,tmp_startPrice);
                    hashItems.put (i, newitem);
                    arrayItems.add (newitem);
                    // System.out.println(items[i].toString());
        }
        Collections.sort(arrayItems);
        /* Create arraylist and hashmap for single-item bids */
        HashMap<Integer,SingleItemBid> hashSingleBids = new
            HashMap<Integer,SingleItemBid> ();

        /* Create arraylist and hashmap for linear bids */
        HashMap<Integer,LinearBid> hashLinearBids = new
            HashMap<Integer,LinearBid> ();

        /* Construct dummies */
        int dummy_id = -1;
        for (int i = 0; i < nItems; i ++, dummy_id--) {
            Item tmp_item = hashItems.get(i);
            SingleItemBid tmp_dummy = new SingleItemBid(tmp_item.reservePrice,
                    tmp_item);
            tmp_dummy.id = dummy_id;
            hashSingleBids.put(dummy_id, tmp_dummy);
        }
        Bid.id_count = 0;

        /* Initialize the priceVector */
        int [] priceVector = new int [nItems];
        for (int i = 0; i < nItems; i ++) {
            priceVector[i] = hashItems.get(i).startPrice;
        }
        /* Initialize the MWMCM and lastMWMCM */
        int [] MWMCM = new int [nItems];
        int [] lastMWMCM = new int [nItems];
        for (int i = 0; i < nItems; i ++) {
            MWMCM[i] = -1;
        }
        while ((line = reader.readLine()) != null) {
            String [] bidding_infos = line.split(" ");
            int type = Integer.parseInt(bidding_infos[0]);
            if (type == 1 || type == 2) { 
                /* update lastMWMCM and MWMCM in response to new insertion */
                for (int i = 0; i < nItems; i ++) {
                    lastMWMCM[i] = MWMCM[i]; // update old MWMCM
                    MWMCM[i] = Integer.parseInt(bidding_infos[i+3]);
                }
                if (type == 1) {
                    /* Single item bid insertion */
                    int tmp_reservePrice = Integer.parseInt(bidding_infos[1]);
                    int tmp_id = Integer.parseInt(bidding_infos[2]);
                    SingleItemBid newBid = new SingleItemBid(tmp_reservePrice,
                            hashItems.get(tmp_id));
                    hashSingleBids.put (newBid.id, newBid);
                    // System.out.println("1 " + tmp_id + ", " + tmp_reservePrice);
                } else if (type == 2) { 
                    /* Linear bid insertion */
                    int intercept = Integer.parseInt(bidding_infos[1]);
                    int slope = Integer.parseInt(bidding_infos[2]);
                    LinearBid newbid = new LinearBid(intercept, slope);
                    hashLinearBids.put (newbid.id, newbid);
                    // System.out.println("2 " + intercept + ", " + slope);
                }

                /* Local variables */
                int itemToincrement = -1;
                int incrementAmount = Integer.MAX_VALUE;
                int tmp_incrementAmount;
                int ZERO_IDX = 0;
                // PHASE ONE: resolve stability violation 3
                // STEP ONE: identify the newly unmatched bid within O(n)
                ArrayList<Integer> oldMatchedBids = new ArrayList<Integer> ();
                ArrayList<Integer> newMatchedBids = new ArrayList<Integer> ();
                for (int i = 0; i < nItems; i++) {
                    if (lastMWMCM[i] != MWMCM[i]) {
                        oldMatchedBids.add(lastMWMCM[i]);
                        newMatchedBids.add(MWMCM[i]);
                    }
                }
                // what remained is the newly unmatched bids
                oldMatchedBids.removeAll(newMatchedBids);
                int nRemainedBids = oldMatchedBids.size();
                int newUnmatchBidIdx = -100;
                if (nRemainedBids == 0) {
                    // in this case, new bid is newly unmatched one
                    newUnmatchBidIdx = Bid.id_count - 1;
                } else if (nRemainedBids == 1) {
                    // in this case, the remained is newly unmatched one
                    newUnmatchBidIdx = oldMatchedBids.get(ZERO_IDX);
                } else {
                    // this branch provides illegal value newUnmatchBidIdx = -1000;
                }
                // System.out.println("newUnmatchBidIdx: " + newUnmatchBidIdx);
                // STEP TWO: deal with stability violation 3
                // (a) for dummy bid
                if (newUnmatchBidIdx < 0) {
                    // find the corresponding item who leave dummy bids
                    int itemIdx;
                    for (itemIdx = 0; itemIdx < nItems; itemIdx++) {
                        if (lastMWMCM[itemIdx] < 0 && MWMCM[itemIdx] >= 0) {
                            break;
                        }
                    }
                    // check violation and increment if violated
                    int wuv_zero = hashItems.get(itemIdx).reservePrice;
                    if (priceVector[itemIdx] < wuv_zero) {
                        incrementAmount = wuv_zero - priceVector[itemIdx];
                        priceVector[itemIdx] += incrementAmount;
                        // System.out.println("newUnmatchBidIdx: -" + itemIdx);
                        print (30, incrementAmount, itemIdx);
                    }
                }
                // (b) for single-item bid 
                else if (hashSingleBids.containsKey(newUnmatchBidIdx)) {
                    SingleItemBid sib = hashSingleBids.get(newUnmatchBidIdx);
                    int offeredItemIdx = sib.toItem.id;
                    int wuv_zero = sib.offer; // offered price

                    if (priceVector[offeredItemIdx] < wuv_zero) {
                        // it is a violation of case 2
                        itemToincrement = offeredItemIdx;
                        incrementAmount = wuv_zero -
                            priceVector[offeredItemIdx]; 
                        assert (itemToincrement >= 0) : 
                            "cannot increment idx < 0";
                        assert (incrementAmount > 0) : 
                            "increment a negative number";
                        priceVector[itemToincrement] += incrementAmount;
                        print (31, incrementAmount, itemToincrement);
                    }
                }
                // (c) for linear bid
                else if (hashLinearBids.containsKey(newUnmatchBidIdx)) {
                    LinearBid lb = hashLinearBids.get(newUnmatchBidIdx);
                    int u_slope = lb.slope;
                    int u_intercept = lb.intercept;
                    // check for violation
                    for (int itemIdx = 0; itemIdx < nItems; itemIdx ++) {
                        Item v_zero = hashItems.get(itemIdx);
                        int v_zero_quality = v_zero.quality;
                        int wuv_zero = u_slope * v_zero_quality + u_intercept;
                        if (priceVector[itemIdx] < wuv_zero) {
                            // violation for case 2 detected!
                            itemToincrement = itemIdx;
                            incrementAmount = wuv_zero - priceVector[itemIdx];

                            assert (itemToincrement >= 0) : 
                                "cannot increment idx < 0";
                            assert (incrementAmount > 0) : 
                                "increment a negative number";
                            priceVector[itemToincrement] += incrementAmount;
                            print (32, incrementAmount, itemToincrement);
                        }
                    }
                }

                // PHASE TWO: given a price-vector with no violation 3
                // no need to apply propagation if nItem = 1
                if (nItems == 1) continue;  
                // We apply an upward and downward update propagation
                incrementAmount = -1;
                // STEP THREE: upward-propagation in O(n)
                int vIdx = arrayItems.get(nItems-1).id;
                int uIdx = MWMCM[vIdx];
                for (int prev = nItems-2; prev >= 0; prev --) {
                    LinearBid u = hashLinearBids.get(uIdx);
                    if (u == null) {
                        // we should start propagation from linear bid
                        // since gap(p,i,j) = 0 if a(i) is single-item bid
                        vIdx = arrayItems.get(prev).id;
                        uIdx = MWMCM[vIdx];
                        continue;
                    }
                    int u_slope = u.slope;
                    int u_intercept = u.intercept;
                    Item v_zero = hashItems.get(vIdx);
                    int v_zero_quality = v_zero.quality;
                    int wuv_zero = u_slope * v_zero_quality + u_intercept;

                    Item prevItem = arrayItems.get(prev);
                    int prevItemId = prevItem.id;
                    int prevItemQuality = prevItem.quality;
                    int prevMatchedBidId = MWMCM[prevItemId];
                    boolean isMatchedBidLinear =
                        hashLinearBids.containsKey(prevMatchedBidId);

                    int wuv_one = u_slope * prevItemQuality +
                        u_intercept;
                    if (wuv_zero - priceVector[vIdx] < wuv_one -
                            priceVector[prevItemId]) {
                        // violation
                        itemToincrement = prevItemId;
                        incrementAmount = wuv_one - wuv_zero +
                            priceVector[vIdx] -
                            priceVector[prevItemId];
                        priceVector[itemToincrement] +=
                            incrementAmount;
                            }
                    // Case 1: propagate update to the item that
                    // is currently matchyed to the single-item bid
                    if (!isMatchedBidLinear) {
                        continue;
                    }
                    // Case 2: propagate update to the item that
                    // is currently matchyed to the linear bid
                    if (isMatchedBidLinear) {
                        // continue the propagation by previous item's
                        // bid
                        vIdx = arrayItems.get(prev).id;
                        uIdx = MWMCM[vIdx];
                    }
                }
                // STEP FOUR: downward-propagation in O(n)
                // uIdx = newMatchedBidIdx;
                vIdx = arrayItems.get(ZERO_IDX).id;
                uIdx = MWMCM[vIdx];
                for (int postv = 1; postv < nItems; postv ++) {
                    LinearBid u = hashLinearBids.get(uIdx);
                    if (u == null) {
                        // we should start propagation from linear bid
                        // since gap(p,i,j) = 0 if a(i) is single-item bid
                        vIdx = arrayItems.get(postv).id;
                        uIdx = MWMCM[vIdx];
                        continue;
                    }
                    int u_slope = u.slope;
                    int u_intercept = u.intercept;
                    Item v_zero = hashItems.get(vIdx);
                    int v_zero_quality = v_zero.quality;
                    int wuv_zero = u_slope * v_zero_quality + u_intercept;

                    Item postvItem = arrayItems.get(postv);
                    int postvItemId = postvItem.id;
                    int postvItemQuality = postvItem.quality;
                    int postvMatchedBidId = MWMCM[postvItemId];

                    boolean isMatchedBidLinear =
                        hashLinearBids.containsKey(postvMatchedBidId);
                    int wuv_one = u_slope * postvItemQuality +
                        u_intercept;
                    if (wuv_zero - priceVector[vIdx] < wuv_one -
                            priceVector[postvItemId]) {
                        // violation
                        itemToincrement = postvItemId;
                        incrementAmount = wuv_one - wuv_zero +
                            priceVector[vIdx] -
                            priceVector[postvItemId];
                        priceVector[itemToincrement] +=
                            incrementAmount;
                            }
                    // Case 1: propagate update to the item that
                    // is currently matchyed to the single-item bid
                    if (!isMatchedBidLinear) {
                        continue;
                    }
                    // Case 2: propagate update to the item that
                    // is currently matchyed to the linear bid
                    if (isMatchedBidLinear) {
                        // continue the propagation by postvious item's
                        // bid
                        vIdx = arrayItems.get(postv).id;
                        uIdx = MWMCM[vIdx];
                    }
                }

    } else if (type == 3) {
        /* In summary */
        String summary = Integer.toString (priceVector[0]);
        for (int i = 1; i < nItems; i ++) {
            summary += " " + Integer.toString (priceVector[i]);
        }
        System.out.println(summary);
    } 
}
}
}
