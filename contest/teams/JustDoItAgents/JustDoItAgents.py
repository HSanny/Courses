############################################################
##    FILENAME:   JustDoItAgents.py    
##    VERSION:    1.0
##    SINCE:      2014-03-28
##    AUTHOR: 
##        Jimmy Lin (xl5224) - JimmyLin@utexas.edu
##	      Aming Ni(an23366) - amingniutcs@gmail.com
##
############################################################
##    Edited by MacVim
##    Documentation auto-generated by Snippet 
############################################################


import distanceCalculator
import capture
import random, time, util
from captureAgents import CaptureAgent
from captureAgents import AgentFactory
from util import nearestPoint
from baselineAgents import DefensiveReflexAgent

class JustDoItAgents (AgentFactory):
  def __init__(self, isRed, first='offense', second='defense', rest='offense'):
      AgentFactory.__init__(self, isRed)
      self.agents = [first, second]
      self.rest = rest

  def getAgent(self, index):
      if len(self.agents) > 0:
          return self.choose(self.agents.pop(0), index)
      else:
          return self.choose(self.rest, index)

  def choose(self, agentStr, index):
      if agentStr == 'keys':
          global NUM_KEYBOARD_AGENTS
          NUM_KEYBOARD_AGENTS += 1
          if NUM_KEYBOARD_AGENTS == 1:
              return keyboardAgents.KeyboardAgent(index)
          elif NUM_KEYBOARD_AGENTS == 2:
              return keyboardAgents.KeyboardAgent2(index)
          else:
              raise Exception('Max of two keyboard agents supported')
      elif agentStr == 'offense':
          return DiabloSlashAgentOne(index)
      elif agentStr == 'defense':
          return DiabloSlashAgentTwo(index)
      else:
          raise Exception("No staff agent identified by " + agentStr)


class DiabloSlashAgentOne (CaptureAgent):
   def __init__(self, index):
       CaptureAgent.__init__(self, index)
	
   def chooseAction(self,gameState):
       actions = gameState.getLegalActions(self.index)
       values = [self.evaluate(gameState, a) for a in actions]
       maxValue = max(values)
       bestActions = [a for a, v in zip(actions, values) if v == maxValue]
       return random.choice(bestActions)
	
   def evaluate(self, gameState, action):
       features = self.getFeatures(gameState, action)
       weights = self.getWeights(gameState, action)
       return features * weights

   def getSuccessor(self, gameState, action):
       successor = gameState.generateSuccessor(self.index, action)
       pos = successor.getAgentState(self.index).getPosition()
       if pos != nearestPoint(pos):
           return successor.generateSuccessor(self.index, action)
       else:
           return successor

#---------------need to find some ways to compute features and weights-----
#--------add more features and change weights as you go......
#---------don't try to do dynamic update weights yet, find as much features as you can-------

   def getFeatures(self, gameState, action):
       features = util.Counter()
       successor = self.getSuccessor(gameState, action)

       #------------feature0: current board score-------------------#
       features['boardScore'] = self.getFeatureZero(successor)
       #------------feature1: Distance to the nearest food--------------#
       features['distanceToFood'] = self.getFeatureOne(successor)
       #------------feature2: closest ghost---------------#
       features['closestGhost'] = self.getFeatureTwo(successor)
       #------------feature3: number of opponent food left----------#
       features['eatableFoodLeft'] = self.getFeatureThree(successor)
       #------------feature4: force the pacman not to take action "stop"---#
       features['noStopOnTheOtherSide'] = self.getFeatureFour(successor,action)
       #------------feature5: penalize the ghost to go back on its own size---#
       features['goBackToOwnSide'] = self.getFeatureFive(successor)

       return features

   def getWeights(self, gameState, action):
       weights = util.Counter()

       #------------feature0: current board score-------------------#
       weights['boardScore'] = self.getFeatureZeroWeight()
       #------------feature1: Distance to the nearest food---------------#
       weights['distanceToFood'] = self.getFeatureOneWeight()
       #------------feature2: closest ghost---------------#
       weights['closestGhost'] = self.getFeatureTwoWeight()
       #------------feature3: number of opponent food left-------------#
       weights['eatableFoodLeft'] = self.getFeatureThreeWeight()
       #------------feature4: force the pacman not to take action "stop"---#
       weights['noStopOnTheOtherSide'] = self.getFeatureFourWeight()
       #------------feature5: penalize the ghost to go back on its own side---#
       weights['goBackToOwnSide'] = 0#self.getFeatureFiveWeight()

       return weights

   def getFeatureFiveWeight(self):
       return 1.0 
   #----------------------feature 5------------------------
   def getFeatureFive(self,successor):
       if(successor.getAgentState(self.index).isPacman): return 1.0
       return 0.0       

   def getFeatureFiveWeight(self):
       return -1.0
 
   #----------------------feature 4------------------------
   def getFeatureFour(self,successor,action):
       if(action == 'Stop' and successor.getAgentState(self.index).isPacman):
           return 1.0
       return 0.0

   def getFeatureFourWeight(self):
       return -1000.0
   #----------------------feature 3-------------------------
   def getFeatureThree(self,successor):
       foodList = self.getFood(successor).asList()
       return len(foodList)

   def getFeatureThreeWeight(self):
       return -10.0

   #----------------------feature 2--------------------------
   def getFeatureTwo(self, successor):
       selfAgent = successor.getAgentState(self.index)
       myPos = selfAgent.getPosition()
       ghostDistance = []
       opponentIndices = self.getOpponents(successor)
       noisyDistances = successor.getAgentDistances()
       for opponentIndex in opponentIndices:
           opponent = successor.getAgentState(opponentIndex)
           ghostPos = opponent.getPosition()
           if(not opponent.isPacman and opponent.scaredTimer == 0):
               if(ghostPos != None):
                   ghostDistance.append(self.getMazeDistance(myPos,ghostPos))
               else:
                   ghostDistance.append(abs(noisyDistances[opponentIndex]))
       #reward the state there isn't any ghosts
       if(len(ghostDistance) == 0): return 1000.0
       return min(ghostDistance)+1

   def getFeatureTwoWeight(self):
       return 10.0

   #----------------------feature 0 --------------------------
   def getFeatureZero(self, successor):
       return self.getScore(successor)

   def getFeatureZeroWeight(self):
       return 100.0

   #----------------------feature 1--------------------------
   def getFeatureOne(self, successor):
       foodList = self.getFood(successor).asList()
       myPos = successor.getAgentState(self.index).getPosition()
       minDistance = min([self.getMazeDistance(myPos,food) for food in foodList])
       return minDistance

   def getFeatureOneWeight(self):
       return -1.5
   
   #----------------------feature 2-------------------------------


#------------------------end---------------------------------------------------


class DiabloSlashAgentTwo (DefensiveReflexAgent):
    def __init__(self, index):
        CaptureAgent.__init__(self, index)
