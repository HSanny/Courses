############################################################
##    FILENAME:   JustDoItAgents.py    
##    VERSION:    1.0
##    SINCE:      2014-03-28
##    AUTHOR: 
##        Jimmy Lin (xl5224) - JimmyLin@utexas.edu
##	      Aming Ni(an23366) - amingniutcs@gmail.com
##
############################################################
##    Edited by MacVim
##    Documentation auto-generated by Snippet 
############################################################


import distanceCalculator
import capture
import random, time, util
from captureAgents import CaptureAgent
from captureAgents import AgentFactory
from util import nearestPoint
from game import Directions

class JustDoItAgents (AgentFactory):
  def __init__(self, isRed, first='offense', second='defense', rest='offense'):
      AgentFactory.__init__(self, isRed)
      self.agents = [first, second]
      self.rest = rest

  def getAgent(self, index):
      if len(self.agents) > 0:
          return self.choose(self.agents.pop(0), index)
      else:
          return self.choose(self.rest, index)

  def choose(self, agentStr, index):
      if agentStr == 'keys':
          global NUM_KEYBOARD_AGENTS
          NUM_KEYBOARD_AGENTS += 1
          if NUM_KEYBOARD_AGENTS == 1:
              return keyboardAgents.KeyboardAgent(index)
          elif NUM_KEYBOARD_AGENTS == 2:
              return keyboardAgents.KeyboardAgent2(index)
          else:
              raise Exception('Max of two keyboard agents supported')
      elif agentStr == 'offense':
          return DiabloSlashAgentOne(index)
      elif agentStr == 'defense':
          return DiabloSlashAgentTwo(index)
      else:
          raise Exception("No staff agent identified by " + agentStr)


class DiabloSlashAgentOne (CaptureAgent):
   def __init__(self, index):
       CaptureAgent.__init__(self, index)
	
   def chooseAction(self,gameState):
       actions = gameState.getLegalActions(self.index)
       values = [self.evaluate(gameState, a) for a in actions]
       maxValue = max(values)
       bestActions = [a for a, v in zip(actions, values) if v == maxValue]
       return random.choice(bestActions)
	
   def evaluate(self, gameState, action):
       features = self.getFeatures(gameState, action)
       weights = self.getWeights(gameState, action)
       return features * weights

   def getSuccessor(self, gameState, action):
       successor = gameState.generateSuccessor(self.index, action)
       pos = successor.getAgentState(self.index).getPosition()
       if pos != nearestPoint(pos):
           return successor.generateSuccessor(self.index, action)
       else:
           return successor

#---------------need to find some ways to compute features and weights-----
#--------add more features and change weights as you go......
#---------don't try to do dynamic update weights yet, find as much features as you can-------

   def getFeatures(self, gameState, action):
       features = util.Counter()
       successor = self.getSuccessor(gameState, action)

       #------------feature0: current board score-------------------#
       features['boardScore'] = self.getFeatureZero(successor)
       #------------feature1: Distance to the nearest food--------------#
       features['distanceToFood'] = self.getFeatureOne(successor)
       #------------feature2: closest ghost---------------#
       features['closestGhost'] = self.getFeatureTwo(successor)
       #------------feature3: number of opponent food left----------#
       features['eatableFoodLeft'] = self.getFeatureThree(successor)
       #------------feature4: force the pacman not to take action "stop"---#
       features['noStop'] = self.getFeatureFour(successor,action)
       #------------feature5: penalize the ghost to go back on its own size---#
       features['goBackToOwnSide'] = self.getFeatureFive(successor)
       #------------feature6: has walls-------------------------
       features['hasWall'] = self.getFeatureSix(successor)

       return features

   def getWeights(self, gameState, action):
       weights = util.Counter()

       #------------feature0: current board score-------------------#
       weights['boardScore'] = self.getFeatureZeroWeight()
       #------------feature1: Distance to the nearest food---------------#
       weights['distanceToFood'] = self.getFeatureOneWeight()
       #------------feature2: closest ghost---------------#
       weights['closestGhost'] = self.getFeatureTwoWeight()
       #------------feature3: number of opponent food left-------------#
       weights['eatableFoodLeft'] = self.getFeatureThreeWeight()
       #------------feature4: force the pacman not to take action "stop"---#
       weights['noStop'] = self.getFeatureFourWeight()
       #------------feature5: penalize the ghost to go back on its own side---#
       weights['goBackToOwnSide'] = self.getFeatureFiveWeight()
       #------------feature6: has walls----------------------------
       weights['hasWall'] = self.getFeatureSixWeight()

       return weights


   #----------------------feature 6------------------------
   def getFeatureSix(self, successor):
       value = 0
       (x,y) = successor.getAgentState(self.index).getPosition()
       walls = []
       walls.append(successor.hasWall(int(x+1),int(y)))
       walls.append(successor.hasWall(int(x),int(y+1)))
       walls.append(successor.hasWall(int(x-1),int(y)))
       walls.append(successor.hasWall(int(x),int(y-1)))
       for wall in walls:
           if(wall): value = value + 1
       if(value != 3): value = 0.0
       return value

   def getFeatureSixWeight(self):
       return -5.0
 
   #----------------------feature 5------------------------
   def getFeatureFive(self,successor):
       if(successor.getAgentState(self.index).isPacman): return -1.0
       return 0.0       

   def getFeatureFiveWeight(self):
       return -10.0
 
   #----------------------feature 4------------------------
   def getFeatureFour(self,successor,action):
       if(action == 'Stop'):
           return 1.0
       return 0.0

   def getFeatureFourWeight(self):
       return -100.0
   #----------------------feature 3-------------------------
   def getFeatureThree(self,successor):
       foodList = self.getFood(successor).asList()
       return len(foodList)

   def getFeatureThreeWeight(self):
       return -10.0

   #----------------------feature 2--------------------------
   def getFeatureTwo(self, successor):
       selfAgent = successor.getAgentState(self.index)
       myPos = selfAgent.getPosition()
       ghostDistance = []
       opponentIndices = self.getOpponents(successor)
       noisyDistances = successor.getAgentDistances()
       for opponentIndex in opponentIndices:
           opponent = successor.getAgentState(opponentIndex)
           ghostPos = opponent.getPosition()
           if(not opponent.isPacman and opponent.scaredTimer == 0):
               if(ghostPos != None):
                   ghostDistance.append(self.getMazeDistance(myPos,ghostPos))
               else:
                   ghostDistance.append(abs(noisyDistances[opponentIndex]))
       #reward the state there isn't any ghosts
       if(len(ghostDistance) == 0): return 1000.0
       return min(ghostDistance)

   def getFeatureTwoWeight(self):
       return 10.0

   #----------------------feature 0 --------------------------
   def getFeatureZero(self, successor):
       return self.getScore(successor)

   def getFeatureZeroWeight(self):
       return 100.0

   #----------------------feature 1--------------------------
   def getFeatureOne(self, successor):
       foodList = self.getFood(successor).asList()
       myPos = successor.getAgentState(self.index).getPosition()
       minDistance = min([self.getMazeDistance(myPos,food) for food in foodList])
       return minDistance

   def getFeatureOneWeight(self):
       return -1.5


#------------------------end---------------------------------------------------


class DiabloSlashAgentTwo (CaptureAgent):
   def __init__(self, index):
       CaptureAgent.__init__(self, index)
	
   def chooseAction(self,gameState):
       actions = gameState.getLegalActions(self.index)
       values = [self.evaluate(gameState, a) for a in actions]
       maxValue = max(values)
       bestActions = [a for a, v in zip(actions, values) if v == maxValue]
       return random.choice(bestActions)
	
   def evaluate(self, gameState, action):
       features = self.getFeatures(gameState, action)
       weights = self.getWeights(gameState, action)
       return features * weights

   def getSuccessor(self, gameState, action):
       successor = gameState.generateSuccessor(self.index, action)
       pos = successor.getAgentState(self.index).getPosition()
       if pos != nearestPoint(pos):
           return successor.generateSuccessor(self.index, action)
       else:
           return successor

#---------------need to find some ways to compute features and weights-----
#--------add more features and change weights as you go......
#---------don't try to do dynamic update weights yet, find as much features as you can-------

   def getFeatures(self, gameState, action):
       features = util.Counter()
       successor = self.getSuccessor(gameState, action)

       #------------feature0: closest ghost---------------#
       features['closestGhost'] = self.getFeatureZero(successor)
       #------------feature1: penalize reverse action-----#
       features['reverseAction'] = self.getFeatureOne(gameState, action)
       #------------feature2: on defense-----------------------------#
       features['onDefense'] = self.getFeatureTwo(successor)
       #------------feature3: eat ghost-------#
       features['eatGhost'] = self.getFeatureThree(successor)
       #------------feature4: has wall--------#
       features['hasWalls'] = self.getFeatureFour(successor)
       #------------feature5: food left---------#
       features['foodLeft'] = self.getFeatureFive(successor)

       return features

   def getWeights(self, gameState, action):
       weights = util.Counter()

       #------------feature0: closest ghost---------------#
       weights['closestGhost'] = self.getFeatureZeroWeight()
       #------------feature1: penalize reverse action-----#
       weights['reverseAction'] = self.getFeatureOneWeight()
       #------------feature2: onDefense-----#
       weights['onDefense'] = self.getFeatureTwoWeight()
       #------------feature3: eat ghost-----#
       weights['eatGhost'] = self.getFeatureThreeWeight()
       #------------feature4: has wall------#
       weights['hasWalls'] = self.getFeatureFourWeight()
       #------------feature5: food left-------#
       weights['foodLeft'] = self.getFeatureFiveWeight()
       #------------feature6: exact ghost position-----#

       return weights

   #----------------------feature 5------------------------
   def getFeatureFive(self,successor):
       foodLeft = 0
       foodList = []
       if( successor.isOnRedTeam(self.index) ):
           foodList = successor.getRedFood().asList()
       else:
           foodList = successor.getBlueFood().asList()
       foodLeft = len(foodList)
       if( foodLeft < 5 ):
           myPos = successor.getAgentState(self.index).getPosition()
           minDistance = min([self.getMazeDistance(myPos,food) for food in foodList])
           return minDistance
       return 0

   def getFeatureFiveWeight(self):
       return -50.0

   #----------------------feature 4------------------------
   def getFeatureFour(self, successor):
       value = 0
       (x,y) = successor.getAgentState(self.index).getPosition()
       walls = []
       walls.append(successor.hasWall(int(x+1),int(y)))
       walls.append(successor.hasWall(int(x),int(y+1)))
       walls.append(successor.hasWall(int(x-1),int(y)))
       walls.append(successor.hasWall(int(x),int(y-1)))
       for wall in walls:
           if(wall): value = value + 1
       if(value != 3): value = 0.0
       return value

   def getFeatureFourWeight(self):
       return -5.0
   #----------------------feature 3-------------------------
   def getFeatureThree(self, successor):
       value = 0
       opponentIndices = self.getOpponents(successor)
       for opponentIndex in opponentIndices:
           opponent = successor.getAgentState(opponentIndex)
           if (opponent.isPacman): value = value + 1
       return value

   def getFeatureThreeWeight(self):
       return -1000

   #----------------------feature 2-------------------------
   def getFeatureTwo(self, successor):
       if(successor.getAgentState(self.index).isPacman): return 1.0
       else: return 0.0

   def getFeatureTwoWeight(self):
       return -100

   #----------------------feature 1--------------------------
   def getFeatureOne(self, gameState, action):
       rev = Directions.REVERSE[gameState.getAgentState(self.index).configuration.direction]
       if action == rev: return 1
       return 0

   def getFeatureOneWeight(self):
       return -5.0

   #----------------------feature 0--------------------------
   def getFeatureZero(self, successor):
       selfAgent = successor.getAgentState(self.index)
       myPos = selfAgent.getPosition()
       ghostDistance = []
       opponentIndices = self.getOpponents(successor)
       noisyDistances = successor.getAgentDistances()
       for opponentIndex in opponentIndices:
           opponent = successor.getAgentState(opponentIndex)
           ghostPos = opponent.getPosition()
           distance = 10000
           if(ghostPos != None):
               distance = self.getMazeDistance(myPos,ghostPos)
           elif(opponent.isPacman):
               distance = abs(noisyDistances[opponentIndex])
	   ghostDistance.append(distance)
       return min(ghostDistance)

   def getFeatureZeroWeight(self):
       return -10.0
