/*##############################################################
## MODULE: Leader.java
## VERSION: 1.0 
## SINCE: 2014-04-02
## AUTHOR: 
##         JIMMY LIN (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

import java.util.concurrent.LinkedBlockingQueue;
import java.util.HashMap;
import java.util.ArrayList;
import java.net.InetAddress;
import java.io.IOException;

class Leader extends Util implements Runnable{
        private LinkedBlockingQueue<String> queue = null;
        // ballotNumber: current ballot number
        private int ballot_num;
        // active: active or passive?
        private boolean isActive = false;
        // proposals: proposals so far
        private HashMap<Integer, String> proposals;

        private int serverID;
        private int numServers;
        private String logHeader;

        private InetAddress localhost;

        private HashMap<Integer, LinkedBlockingQueue<String>> scoutQueues;
        private HashMap<Integer, LinkedBlockingQueue<String>> commanderQueues;
        
        public Leader(LinkedBlockingQueue<String> queue, int id, int numServers, InetAddress localhost) {
            this.queue = queue;
            this.ballot_num = 0;
            this.serverID = id;
            this.numServers = numServers;
            this.logHeader = String.format(LEADER_LOG_HEADER, id);
            this.localhost = localhost;
        }
        
        public void run() {
            // Spawn a Scout for the current ballot number
            LinkedBlockingQueue<String> queueScout = new LinkedBlockingQueue<String>();
            (new Thread(new Scout(queueScout, serverID, numServers, ballot_num, localhost))).start(); 
            scoutQueues.put(ballot_num, queueScout);
            while(true) {
                // receive messages from queue
                String msg = null;
                try {
                    msg = queue.take();
                }  catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (msg == null) continue;
                String[] msgParts = msg.split(MESSAGE_SEP);
                String title = msgParts[TITLE_IDX];
                String content = msgParts[CONTENT_IDX];
                String[] contentParts = content.split(CONTENT_SEP); 
                // if message is a p1b
                if(title.equals(P1B_TITLE)) {
                
                // if message is a p2b
                } else if(title.equals(P2B_TITLE)) {
                
                // if message is a propose
                } else if(title.equals(PROPOSE_TITLE)) {
                    int s = Integer.parseInt(contentParts[0]);
                    String p = contentParts[1];
                    // if Leader hasn't proposed something for this slot already
                    if(proposals.get(s) == null) {
                        // add this proposal to list of proposals so far
                        proposals.put(s,p);
                        // if the Leader is active
                        if(isActive) {
                            // spawn a Commander for this ballot
                            LinkedBlockingQueue<String> queueCommander = new LinkedBlockingQueue<String>();
                            (new Thread(new Commander(queueCommander, numServers, numServers, String.format(PVALUE_CONTENT, ballot_num, s, p), localhost))).start(); 
                            commanderQueues.put(ballot_num, queueCommander);
                        }

                        // if message is an adopted
                    } else if(title.equals(ADOPTED_TITLE)) {
                        int b = Integer.parseInt(contentParts[0]);
                        String[] pvals = contentParts[1].split(ACCEPTED_SEP);
                        // update proposals so far with highest ballots for each slot returned by the adopted message
                        for(String newPval:pmax(pvals)) {
                            // for each proposal in the pmax
                            String[] newPvalParts = newPval.split(PVALUE_SEP);
                            int newS = Integer.parseInt(newPvalParts[1]);
                            String newP = newPvalParts[2];
                            // update proposals with that pvalue
                            proposals.put(s,p);
                        }
                        // for all proposals so far
                        for(int tmp_s: proposals.keySet()) {
                        // spawn a Commander for that proposal
                            // spawn a Commander for this ballot
                            LinkedBlockingQueue<String> queueCommander = new LinkedBlockingQueue<String>();
                            (new Thread(new Commander(queueCommander, numServers, numServers, String.format(PVALUE_CONTENT, ballot_num, tmp_s, proposals.get(tmp_s)), localhost))).start(); 
                            commanderQueues.put(ballot_num, queueCommander);
                            
                        }
                        // become Active
                        isActive = true; 
                        // if message is a preempted
                    } else if(title.equals(PREEMPTED_TITLE)) {
                        // TODO: Why does the pseudocode show <r', L'> instead of b?
                        int b = Integer.parseInt(contentParts[0]); 
                        // if the ballot number in the message is greater than the current ballot number
                        if(b > ballot_num) {
                            // become Passive
                            isActive = false;
                            // update the ballot number
                            // TODO: Change this to ensure globally unique
                            ballot_num = b + 1;
                            // spawn a scout for the new ballot number
                            queueScout = new LinkedBlockingQueue<String>();
                            (new Thread(new Scout(queueScout, serverID, numServers, ballot_num, localhost))).start(); 
                            scoutQueues.put(ballot_num, queueScout);
                        }
                    }
                }
            }
        }

        private String[] pmax (String[] pvals) {
            /*
            * pmax takes an array of pvalues and returns an array of pvalues
            * where for each slot number that exists in the original array,
            * the pvalue with the highest ballot number is added to the new array
            */
            // TODO: Edit this so it doesn't look at a given pval more than once
            ArrayList<String> pmax = new ArrayList<String>();
            for(String pval: pvals) {
                String[] pvalParts = pval.split(PVALUE_SEP);
                int s = Integer.parseInt(pvalParts[1]);
                int maxB = -1;
                String maxPval = null;
                // Pick the pvalue with the largest ballot number for a given slot number
                for(String tmp_pval: pvals) {
                    String[] tmp_pvalParts = tmp_pval.split(PVALUE_SEP);
                    int tmp_b = Integer.parseInt(tmp_pvalParts[0]);
                    int tmp_s = Integer.parseInt(tmp_pvalParts[1]);
                    if(tmp_s == s && tmp_b > maxB) {
                        maxB = tmp_b;
                        maxPval = pval;
                    }
                }
                if (pmax != null) pmax.add (maxPval);
            }
            return (String []) pmax.toArray();
        }

        class Scout implements Runnable { 
            private LinkedBlockingQueue<String> queue = null;
            private int leaderID;
            // waitFor: the acceptors that the scout is still waiting for
            // 0 means still waiting, 1 means received
            private int[] waitFor;
            // pValues: the set of pValues received so far
            ArrayList<String> pvalues;

            private InetAddress localhost;
            private String logHeader;

            public Scout (LinkedBlockingQueue<String> queue, int leaderID, int numAcceptors, int ballot_num, InetAddress localhost) {
                this.queue = queue;
                this.leaderID = leaderID;
                this.waitFor = new int[numAcceptors];
                this.pvalues = new ArrayList<String>();
                this.logHeader = String.format(SCOUT_LOG_HEADER, ballot_num);
                this.localhost = localhost;
            }

            public void run () {
                // for all acceptors
                for(int a=0; a<waitFor.length; a++) {
                    // send <p1a, leader, ballot number>
                    int port = SERVER_PORT_BASE + a;
                    String p1aContent = String.format(P1A_CONTENT, leaderID, ballot_num);
                    String p1aMessage = String.format(MESSAGE, LEADER_TYPE,
                        leaderID, ACCEPTOR_TYPE, a, P1A_TITLE, p1aContent);
                    try {
                        send(localhost, port, p1aMessage, logHeader);
                    } catch (IOException e) {
                        continue;
                    }
                }
                while(true) {
                    // receive messages from queue
                    String msg = null;
                    try {
                        msg = queue.take();
                    }  catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (msg == null) continue;
                    String[] msgParts = msg.split(MESSAGE_SEP);
                    String title = msgParts[0];
                    if(title.equals(P1B_TITLE)) {
                        String[] p1bParts = msgParts[1].split(CONTENT_SEP);
                        int acceptor = Integer.parseInt(p1bParts[0]);
                        int newBallotNum = Integer.parseInt(p1bParts[1]);
                        String pval = p1bParts[2];
                        // if message is a p1b for the same ballot number
                        if(newBallotNum == ballot_num) {
                            // add pvalues to pValues
                            pvalues.add(pval); 
                            // remove acceptor from waitFor
                            waitFor[acceptor] = 1;
                            int numReceived = 0;
                            for(int tmp_a: waitFor)
                                if(tmp_a == 1)
                                    ++numReceived;
                            // if waiting for fewer than half of all acceptors
                            if(numReceived > waitFor.length/2) {
                                // send adopted, ballot number, pValues to leader
                                int port = SERVER_PORT_BASE + leaderID;
                                String adopted_str = "";
                                for (String pvalue : pvalues) {
                                    adopted_str += pvalue + PVALUE_SEP;
                                }
                                adopted_str = adopted_str.substring(0, adopted_str.length()-PVALUE_SEP.length());
                                String adoptedContent = String.format(ADOPTED_CONTENT, ballot_num, adopted_str);
                                String adoptedMessage = String.format(MESSAGE, LEADER_TYPE,
                                    leaderID, LEADER_TYPE, leaderID, ADOPTED_TITLE, adoptedContent);
                                try {
                                    send(localhost, port, adoptedMessage, logHeader);
                                } catch (IOException e) {
                                    continue;
                                }
                                // exit
                                return; 
                            }
                        } else {
                        // else send preempted and the higher ballot number to leader
                            int port = SERVER_PORT_BASE + leaderID;
                            String preemptedContent = String.format(PREEMPTED_CONTENT, newBallotNum);
                            String preemptedMessage = String.format(MESSAGE, LEADER_TYPE,
                                leaderID, LEADER_TYPE, leaderID, PREEMPTED_TITLE, preemptedContent);
                            try {
                                send(localhost, port, preemptedMessage, logHeader);
                            } catch (IOException e) {
                                continue;
                            }
                            // exit
                            return;
                        }
                    }
                }
            }
        }

        class Commander implements Runnable {
            private LinkedBlockingQueue<String> queue = null;
            // waitFor: the acceptors that the commander is still waiting for
            // 0 means still waiting, 1 means received
            private int[] waitFor;
            private int numServers;

            private int leaderID;

            private int ballot_num;
            private int slot_num;
            private String p;

            private InetAddress localhost;
            
            public Commander(LinkedBlockingQueue<String> queue, int numAcceptors, int numServers, String pval, InetAddress localhost) {
                this.queue = queue;
                this.waitFor = new int[numAcceptors];
                this.numServers = numServers;
                String[] pvalParts = pval.split(PVALUE_SEP);
                this.ballot_num = Integer.parseInt(pvalParts[0]);
                this.slot_num = Integer.parseInt(pvalParts[1]);
                this.p = pvalParts[2];
            }

            public void run() {
                // for all acceptors
                for(int a=0; a<waitFor.length; a++) {
                    // send <p2a, leader, ballot>
                    int port = SERVER_PORT_BASE + a;
                    String p2aContent = String.format(P2A_CONTENT, leaderID, String.format(PVALUE_CONTENT, ballot_num, slot_num, p));
                    String p2aMessage = String.format(MESSAGE, LEADER_TYPE,
                            leaderID, ACCEPTOR_TYPE, a, P2A_TITLE, p2aContent);
                    try {
                        send(localhost, port, p2aMessage, logHeader);
                    } catch (IOException e) {
                        continue;
                    }
                }
                while(true) {
                    // receive messages from queue   
                    String msg = null;
                    try {
                        msg = queue.take();
                    }  catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (msg == null) continue;
                    String[] msgParts = msg.split(MESSAGE_SEP);
                    String title = msgParts[0];
                    if(title.equals(P2B_TITLE)) {
                        String[] p2bParts = msgParts[1].split(CONTENT_SEP);
                        int acceptor = Integer.parseInt(p2bParts[0]);
                        int newBallotNum = Integer.parseInt(p2bParts[1]);
                        // if message is a p2b for the same ballot number
                        if(newBallotNum == ballot_num) {
                            // remove acceptor from waitFor
                            waitFor[acceptor] = 1;
                            // remove acceptor from waitFor
                            waitFor[acceptor] = 1;
                            int numReceived = 0;
                            for(int tmp_a: waitFor)
                                if(tmp_a == 1)
                                    ++numReceived;
                            // if waiting for fewer than half of all acceptors
                            if(numReceived > waitFor.length/2) {
                                // send decision to ALL servers
                                for(int r=0; r<numServers; r++) {
                                    int port = SERVER_PORT_BASE + leaderID;
                                    String decisionContent = String.format(DECISION_CONTENT, slot_num, p);
                                    String decisionMessage = String.format(MESSAGE, LEADER_TYPE,
                                        leaderID, SERVER_TYPE, leaderID, DECISION_TITLE, decisionContent);
                                    try {
                                        send(localhost, port, decisionMessage, logHeader);
                                    } catch (IOException e) {
                                        continue;
                                    }
                                }
                                return;
                            }
                        // else send preempted and the higher ballot number to leader
                        } else {
                            int port = SERVER_PORT_BASE + leaderID;
                            String preemptedContent = String.format(PREEMPTED_CONTENT, newBallotNum);
                            String preemptedMessage = String.format(MESSAGE, LEADER_TYPE,
                                leaderID, LEADER_TYPE, leaderID, PREEMPTED_TITLE, preemptedContent);
                            try {
                                send(localhost, port, preemptedMessage, logHeader);
                            } catch (IOException e) {
                                continue;
                            }
                            // exit
                            return;
                        }
                    }
                }
            }
        }
}
