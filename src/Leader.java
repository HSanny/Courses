/*##############################################################
## MODULE: Leader.java
## VERSION: 1.0 
## SINCE: 2014-04-02
## AUTHOR: 
##         JIMMY LIN (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

import java.util.concurrent.LinkedBlockingQueue;
import java.util.HashMap;
import java.util.ArrayList;
import java.net.InetAddress;

class Leader extends Util implements Runnable{
        private LinkedBlockingQueue<String> queue = null;
        // ballotNumber: current ballot number
        private int ballot_num;
        // active: active or passive?
        private boolean isActive = false;
        // proposals: proposals so far
        private HashMap<Integer, String> proposals;

        private int serverID;
        private String logHeader;

        private InetAddress localhost;

        private HashMap<Integer, LinkedBlockingQueue<String>> scoutQueues;
        private HashMap<Integer, LinkedBlockingQueue<String>> commanderQueues;
        
        public Leader(LinkedBlockingQueue<String> queue, int id, InetAddress localhost) {
            this.queue = queue;
            this.ballot_num = 0;
            this.serverID = id;
            this.logHeader = String.format(LEADER_LOG_HEADER, id);
            this.localhost = localhost;
        }
        
        public void run() {
            // Spawn a Scout for the current ballot number
            LinkedBlockingQueue<String> queueScout = new LinkedBlockingQueue<String>();
            // TODO: Change scout arguments
            (new Thread(new Scout(queueScout, ballot_num))).start(); 
            scoutQueues.put(ballot_num, queueScout);
        
            while(true) {
                // receive messages from queue
                String msg = null;
                try {
                    msg = queue.take();
                }  catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (msg == null) continue;
                String[] msgParts = msg.split(MESSAGE_SEP);
                String title = msgParts[TITLE_IDX];
                String content = msgParts[CONTENT_IDX];
                String[] contentParts = content.split(CONTENT_SEP); 
                // if message is a p1b
                // if message is a p2b
                // if message is a propose
                if(title.equals(PROPOSE_TITLE)) {
                    int s = Integer.parseInt(contentParts[0]);
                    String p = contentParts[1];
                    // if Leader hasn't proposed something for this slot already
                    if(proposals.get(s) == null) {
                        // add this proposal to list of proposals so far
                        proposals.put(s,p);
                        // if the Leader is active
                        if(isActive) {
                            // spawn a Commander for this ballot
                            LinkedBlockingQueue<String> queueCommander = new LinkedBlockingQueue<String>();
                            // TODO: Change commander arguments
                            (new Thread(new Commander(queueCommander, ballot_num))).start(); 
                            commanderQueues.put(ballot_num, queueCommander);
                        }
                    }
                // if message is an adopted
                } else if(title.equals(ADOPTED_TITLE)) {
                    int b = Integer.parseInt(contentParts[0]);
                    String[] pvals = contentParts[1].split(ACCEPTED_SEP);
                    // update proposals so far with highest ballots for each slot returned by the adopted message
                    for(String newPval:pmax(pvals)) {
                        //TODO: Continue here 
                    }
                    // for all proposals so far
                        // spawn a Commander for that proposal
                    // become Active
                // if message is a preempted
                } else if(title.equals(PREEMPTED_TITLE)) {
                    // if the ballot number in the message is greater than the current ballot number
                        // become Passive
                        // update the ballot number
                        // spawn a scout for the new ballot number
                }
            }
        }

        private String[] pmax (String[] pvals) {
            // TODO: Edit this so it doesn't look at a given pval more than once
            ArrayList<String> pmax = new ArrayList<String>();
            for(String pval: pvals) {
                String[] pvalParts = pval.split(PVALUE_SEP);
                int s = Integer.parseInt(pvalParts[1]);
                int maxB = -1;
                String maxPval = null;
                // Pick the pvalue with the largest ballot number for a given slot number
                for(String tmp_pval: pvals) {
                    String[] tmp_pvalParts = tmp_pval.split(PVALUE_SEP);
                    int tmp_b = Integer.parseInt(tmp_pvalParts[0]);
                    int tmp_s = Integer.parseInt(tmp_pvalParts[1]);
                    if(tmp_s == s && tmp_b > maxB) {
                        maxB = tmp_b;
                        maxPval = pval;
                    }
                }
                if (pmax != null) pmax.add (maxPval);
            }
            return (String []) pmax.toArray();
        }

        class Scout implements Runnable { 
            private LinkedBlockingQueue queue = null;
            // waitFor: the acceptors that the scout is still waiting for
            // pValues: the set of pValues received so far

            public Scout (LinkedBlockingQueue queue, int ballot_num) {
                this.queue = queue;
            }

            public void run () {
                // for all acceptors
                    // send <p1a, leader, ballot number>
                // while true
                    // receive messages from queue
                    // if message is a p1b for the same ballot number
                        // add pvalues to pValues
                        // remove acceptor from waitFor
                        // if waiting for fewer than half of all acceptors
                            // send adopted, ballot number, pValues to leader
                            // exit
                    // else send preempted and the higher ballot number to leader
                    // exit
            }
        }

        class Commander implements Runnable {
            private LinkedBlockingQueue queue = null;
            // waitFor: the acceptors that the commander is still waiting for
            
            public Commander(LinkedBlockingQueue queue, int ballot_num) {
                this.queue = queue;
            }

            public void run() {
               // for all acceptors
                   // send <p2a, leader, ballot>
               // while true
                   // receive messages from queue   
                   // if message is a p2b for the same ballot number
                       // remove acceptor from waitFor
                       // if waiting for fewer than half of all acceptors
                           // send decision to ALL servers
                   // else send preempted and the higher ballot number to leader
            }
        }
}
