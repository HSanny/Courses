/*##############################################################
## MODULE: Server.java
## VERSION: 1.0 
## SINCE: 2014-03-30
## AUTHOR: 
##     JIMMY LIN (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##     Server Class of PAXOS consensus algorithm ## 
################################################################# ## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.File;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.InetAddress;
import java.util.HashSet;
import java.util.HashMap; 
import java.util.concurrent.LinkedBlockingQueue;

class Server extends Util { // a.k.a. Replica
    /* Configuration */
    static String logHeader;
    static String logfilename;

    /* Knowledge of global scenario */
    static int serverID;
    static int numServers;

    /* Replica's attributes */
    static int slot_num;
    static HashMap<Integer, String> proposals;
    static HashMap<Integer, String> decisions;

    /* Collocation: put leader and acceptor together */
    static Leader leader;
    static Acceptor acceptor;
    static LinkedBlockingQueue<String> queueLeader;
    static LinkedBlockingQueue<String> queueAcceptor;

    public static void main (String [] args) throws IOException, InterruptedException {
        // parse the server id assigned by master
        serverID = Integer.parseInt(args[0]);
        numServers = Integer.parseInt(args[1]);
        // configure the LOG setting
        logHeader = String.format(SERVER_LOG_HEADER, serverID);
        logfilename = String.format(SERVER_LOG_FILENAME, serverID);
        PrintStream log = new PrintStream (new File(logfilename));
        // redirect output to specified file
        System.setOut(log);
        System.setErr(log);

        // Initialize replica's attribute
        slot_num = 1;
        proposals = new HashMap<Integer, String> ();
        decisions = new HashMap<Integer, String> ();

        // Initialization for collocation technique
        leader = new Leader(queueLeader); 
        acceptor = new Acceptor(queueAcceptor);
        queueLeader = new LinkedBlockingQueue<String> ();
        queueAcceptor = new LinkedBlockingQueue<String> ();

        InetAddress localhost = InetAddress.getLocalHost();
        // construct stable server socket
        ServerSocket listener = new ServerSocket(SERVER_PORT_BASE+serverID, 0,
                InetAddress.getLocalHost());
        listener.setReuseAddress(true);
        // send acknowledge to the master
        String setup_ack = String.format(MESSAGE, SERVER_TYPE, serverID,
                MASTER_TYPE, 0, START_ACK_TITLE, EMPTY_CONTENT);
        send(localhost, MASTER_PORT, setup_ack, logHeader);
        // indicate the socket listener setup
        System.out.println(logHeader + listener.toString());
        // 
        try {
            while (true) {
                Socket socket = listener.accept();
                try {
                   BufferedReader in = new BufferedReader(new
                           InputStreamReader(socket.getInputStream()));
                   // channel is established
                   // TODO: process received message
                   String recMessage = in.readLine();
                   System.out.println(logHeader + "Message Received: " + recMessage);
                   String [] recInfo = recMessage.split(",");

                   String sender_type = recInfo[SENDER_TYPE_IDX];
                   int sender_idx = Integer.parseInt(recInfo[SENDER_INDEX_IDX]);
                   String receiver_type = recInfo[RECEIVER_TYPE_IDX];
                   int receiver_idx = Integer.parseInt(recInfo[RECEIVER_INDEX_IDX]);
                   String title = recInfo[TITLE_IDX];
                   String content = recInfo[CONTENT_IDX];

                   // Check if message is propose, p1b, p2b, adopted, or preempted
                   // If so, add to Leader queue
                   if (receiver_type.equals(LEADER_TYPE)) {
                        queueLeader.put(recMessage);
                   }
                   // Check if message is p1a or p2a
                   // If so, add to Acceptor queue
                   if (receiver_type.equals(ACCEPTOR_TYPE)) {
                        queueAcceptor.put(recMessage);
                   }

                   // Check if message is request
                   if (title.equals(REQUEST_TITLE)) {
                       for (String value: decisions.values()) {
                           if (content.equals(value)) {
                               // ignore this request since decided
                               continue; 
                           }
                       }
                       // this request has not been decided
                       // Determine the lowest unused slot number
                       // TODO: verify correctness
                       int s = slot_num + 1;
                       // put <s, p> to proposals
                       proposals.put(s, content);
                       // send <propose, s, p> to all leaders
                       for (int serverIndex = 0; serverIndex < numServers; serverIndex++) {
                           String sp = String.format("%d;%s", s, content);
                           String proposeMessage = String.format(MESSAGE,
                                   SERVER_TYPE, serverID, LEADER_TYPE,
                                   serverIndex, PROPOSE_TITLE, sp);
                           int port = SERVER_PORT_BASE + serverIndex;
                           send (localhost, port, proposeMessage, SERVER_LOG_HEADER);
                       }
                   }

                   // this message is only given by master
                   if (title.equals(EXIT_TITLE) && sender_type.equals(MASTER_TYPE)) {
                        socket.close();
                        listener.close();
                        System.out.println(logHeader + "Exit.");
                        System.exit(0);
                   }

                } finally {
                    socket.close();
                }
            }
        } finally {
            listener.close();
        }
    }
}
